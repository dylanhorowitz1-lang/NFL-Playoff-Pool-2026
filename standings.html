<!doctype html>
<html>
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Standings</title>
  <style>
    :root{
      --bg:#0b1020;
      --card:#111a33;
      --card2:#0f1730;
      --text:#e8ecff;
      --muted:#a9b3da;
      --accent:#5eead4;
      --border: rgba(255,255,255,.12);
      --shadow: 0 12px 30px rgba(0,0,0,.35);

      --grid: rgba(255,255,255,.18);
      --sep: rgba(255,255,255,.22);
      --totalBorder: rgba(255,255,255,.40);
      --subtotalTint: rgba(94,234,212,.10);
      --totalTint: rgba(99,102,241,.16);
    }
    *{box-sizing:border-box}
    body{
      margin:0;
      font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Arial, "Apple Color Emoji","Segoe UI Emoji";
      background: radial-gradient(1200px 500px at 20% -10%, rgba(94,234,212,.18), transparent 60%),
                  radial-gradient(900px 500px at 100% 0%, rgba(99,102,241,.22), transparent 55%),
                  var(--bg);
      color:var(--text);
      min-height:100vh;
    }
    .wrap{max-width:1200px;margin:0 auto;padding:28px 16px 44px}
    .top{
      display:flex;align-items:flex-start;justify-content:space-between;gap:16px;flex-wrap:wrap;
      padding:18px 18px 10px;border:1px solid var(--border);border-radius:18px;background:rgba(17,26,51,.55);
      box-shadow: var(--shadow); backdrop-filter: blur(10px);
    }
    h1{margin:0;font-size:28px;letter-spacing:.2px}
    .sub{margin:6px 0 0;color:var(--muted);max-width:860px;line-height:1.45}
    .pill{
      display:inline-flex;align-items:center;gap:8px;
      padding:8px 10px;border:1px solid var(--border);border-radius:999px;
      color:var(--muted);font-size:12px;background:rgba(15,23,48,.55)
    }
    .nav{margin-top:12px;display:flex;gap:10px;flex-wrap:wrap;}
    .btn{
      display:inline-flex;align-items:center;gap:8px;
      padding:10px 12px;border-radius:12px;
      border:1px solid var(--border);
      background: rgba(15,23,48,.65);
      color:var(--text);
      text-decoration:none;
      transition: transform .12s ease, border-color .12s ease;
      cursor:pointer;
    }
    .btn:hover{transform: translateY(-1px);border-color: rgba(94,234,212,.45)}
    .card{
      margin-top:18px;border:1px solid var(--border);border-radius:18px;
      background: linear-gradient(180deg, rgba(17,26,51,.75), rgba(15,23,48,.65));
      box-shadow: var(--shadow);padding:14px;overflow-x:auto;
    }

    /* Toggle support */
    .hidden-col{ display:none !important; }

    /* ===== TABLE ===== */
    #tbl{
      border-collapse: collapse;
      width: 100%;
      min-width: 1200px;
      table-layout: fixed; /* makes widths predictable */
    }
    #tbl th, #tbl td{
      border: 1px solid var(--grid);
      padding: 7px 8px;
      text-align: center;
      vertical-align: middle;
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
      font-size: 13px;
    }
    #tbl th.name, #tbl td.name{
      text-align: left;
      font-weight: 700;
      white-space: nowrap;
    }
    #tbl thead th{
      position: sticky;
      top: 0;
      background: rgba(15,23,48,.95);
      z-index: 2;
    }

    /* Column widths (even + predictable) via <colgroup> */
    #tbl col.c-rank{ width: 44px; }
    #tbl col.c-name{ width: 180px; }

    /* Pick columns */
    #tbl col.c-adv{ width: 72px; }
    #tbl col.c-spread{ width: 72px; }
    #tbl col.c-ou{ width: 54px; }

    /* Subtotals */
    #tbl col.c-subtotal{ width: 70px; }

    /* SB prediction cols */
    #tbl col.c-pred{ width: 78px; }

    /* Total + Tiebreaker */
    #tbl col.c-total{ width: 82px; }
    #tbl col.c-tb{ width: 60px; }

    /* Separators after each round subtotal */
    .block-end{
      border-right: 2px solid var(--sep) !important;
    }

    /* Subtotal emphasis */
    .subtotal{
      background: var(--subtotalTint);
      font-weight: 800;
    }

    /* TOTAL column emphasis: bold border around the whole column (header + body) */
    .totalcol{
      background: var(--totalTint);
      font-weight: 900;
      border-left: 3px solid var(--totalBorder) !important;
      border-right: 3px solid var(--totalBorder) !important;
    }
    /* Cap the total column so it looks boxed */
    #tbl thead .totalcol{ border-top: 3px solid var(--totalBorder) !important; }
    #tbl tbody tr:last-child .totalcol{ border-bottom: 3px solid var(--totalBorder) !important; }

    /* Tighten tiebreaker */
    .tbcol{
      font-size: 12px;
      color: rgba(232,236,255,.85);
    }

    #msg{ color:var(--muted); font-size:12px; margin-top:10px; }
    
 /* Widen Rank column so header fits */
    #tbl thead th:first-child,
#tbl tbody td:first-child {
  width: 60px;
}
  </style>
</head>
<body>
  <div class="wrap">
    <div class="top">
      <div>
        <h1>Standings</h1>
        <p class="sub">Scores update when games are final.</p>
        <div class="nav">
          <a class="btn" href="index.html">Home</a>
          <a class="btn" href="wildcard.html">Wild Card Picks</a>
          <a class="btn" href="superbowl.html">Super Bowl Predictions</a>
        </div>
      </div>
      <div class="pill">Manual refresh</div>
    </div>

    <div id="msg"></div>

    <div class="card">
      <table id="tbl">
        <!-- widths -->
        <colgroup>
          <col class="c-rank">
          <col class="c-name">

          <!-- WC: adv, spread, ou, subtotal -->
          <col class="c-adv"><col class="c-spread"><col class="c-ou"><col class="c-subtotal">

          <!-- DIV -->
          <col class="c-adv"><col class="c-spread"><col class="c-ou"><col class="c-subtotal">

          <!-- CONF -->
          <col class="c-adv"><col class="c-spread"><col class="c-ou"><col class="c-subtotal">

          <!-- SB game: adv, spread, ou -->
          <col class="c-adv"><col class="c-spread"><col class="c-ou">

          <!-- SB preds: AFC, NFC, Champ, Total SB -->
          <col class="c-pred"><col class="c-pred"><col class="c-pred"><col class="c-subtotal">

          <!-- Total + TB -->
          <col class="c-total"><col class="c-tb">
        </colgroup>

        <thead>
          <tr>
            <th rowspan="2">Rank</th>
            <th rowspan="2" class="name">Entrant</th>

            <th colspan="4">Wild Card</th>
            <th colspan="4" class="future-round">Divisional</th>
            <th colspan="4" class="future-round">Conference Championships</th>
            <th colspan="7" class="future-round">Super Bowl</th>

            <th rowspan="2" class="totalcol">Total</th>
            <th rowspan="2" class="tbcol">Tie-breaker</th>
          </tr>

          <tr>
            <th>Adv</th><th>Spread</th><th>O/U</th><th class="subtotal block-end">Total</th>

            <th class="future-round">Adv</th><th class="future-round">Spread</th><th class="future-round">O/U</th><th class="future-round subtotal block-end">Total</th>

            <th class="future-round">Adv</th><th class="future-round">Spread</th><th class="future-round">O/U</th><th class="future-round subtotal block-end">Total</th>

            <th class="future-round">Adv</th><th class="future-round">Spread</th><th class="future-round">O/U</th>
            <th class="future-round">AFC</th><th class="future-round">NFC</th><th class="future-round">SB Champ</th><th class="future-round subtotal block-end">Total</th>
          </tr>
        </thead>

        <tbody id="tbody"></tbody>
      </table>
    </div>
  </div>

<script>
(() => {
  "use strict";

  // ===== ESPN SCOREBOARD (for finals + champ winners) =====
  const SCOREBOARD_URLS = [
    "https://api.codetabs.com/v1/proxy/?quest=" + encodeURIComponent(
      "https://site.api.espn.com/apis/site/v2/sports/football/nfl/scoreboard"
    ),
    "https://corsproxy.io/?" + encodeURIComponent(
      "https://site.api.espn.com/apis/site/v2/sports/football/nfl/scoreboard"
    )
  ];

  // ===== SCORING WEIGHTS =====
  const SC = {
    WC:   { adv: 3,    ats: 2,   ou: 1   },
    DIV:  { adv: 4.5,  ats: 3,   ou: 1.5 },
    CONF: { adv: 9,    ats: 6,   ou: 3   },
    SB:   { adv: 13.5, ats: 9,   ou: 4.5 },
    PRED: { afc: 4.5, nfc: 4.5, both: 1.5, champ: 7.5 }
  };

  const msgEl = document.getElementById("msg");
  const tbodyEl = document.getElementById("tbody");
  const tableEl = document.getElementById("tbl");

  function norm(s) { return String(s || "").trim().toLowerCase(); }

  function splitCSVLine(line) {
    const out = [];
    let cur = "", inQ = false;
    for (let i = 0; i < line.length; i++) {
      const ch = line[i];
      if (ch === '"') {
        if (inQ && line[i+1] === '"') { cur += '"'; i++; }
        else inQ = !inQ;
      } else if (ch === ',' && !inQ) {
        out.push(cur); cur = "";
      } else cur += ch;
    }
    out.push(cur);
    return out.map(x => x.trim());
  }

  function parseCSV(text) {
    const lines = text.replace(/\r/g, "").split("\n").filter(l => l.trim() !== "");
    if (lines.length < 2) return [];
    const headers = splitCSVLine(lines[0]);
    return lines.slice(1).map(line => {
      const cols = splitCSVLine(line);
      const obj = {};
      headers.forEach((h, i) => obj[h] = (cols[i] ?? ""));
      return obj;
    });
  }

  async function fetchJsonWithFallback(urls) {
    for (const u of urls) {
      try {
        const r = await fetch(u, { cache: "no-store" });
        if (!r.ok) continue;
        return await r.json();
      } catch (e) {}
    }
    throw new Error("Failed to fetch scoreboard");
  }

  async function fetchTextOrNull(path) {
    try {
      const r = await fetch(path, { cache: "no-store" });
      if (!r.ok) return null;
      return await r.text();
    } catch (e) { return null; }
  }

  function parseLines(linesText) {
    const rows = parseCSV(linesText);
    const map = new Map();
    rows.forEach(r => {
      const gid = String(r.GameID || r.GAMEID || r.gameid || "").trim();
      const hs = Number(r.HomeSpread ?? r.homespread);
      const tot = Number(r.Total ?? r.total);
      if (!gid || Number.isNaN(hs) || Number.isNaN(tot)) return;
      map.set(gid, { homeSpread: hs, total: tot });
    });
    return map;
  }

  function eventInfo(ev) {
    const comp = ev.competitions?.[0];
    const teams = comp?.competitors || [];
    const away = teams.find(t => t.homeAway === "away");
    const home = teams.find(t => t.homeAway === "home");

    const awayName = away?.team?.displayName || "Away";
    const homeName = home?.team?.displayName || "Home";
    const awayScore = Number(away?.score ?? NaN);
    const homeScore = Number(home?.score ?? NaN);

    const isFinal = comp?.status?.type?.completed === true;
    const winnerTeam = isFinal ? (teams.find(t => t.winner === true)?.team?.displayName || "") : "";
    return { awayName, homeName, awayScore, homeScore, isFinal, winnerTeam, name: (ev.name || ev.shortName || "") };
  }

  function computeATSWinnerAndHomeMargin(info, homeSpread) {
    const homeMargin = (info.homeScore + homeSpread) - info.awayScore;
    let winner = "Push";
    if (homeMargin > 0) winner = info.homeName;
    else if (homeMargin < 0) winner = info.awayName;
    return { atsWinner: winner, homeMargin };
  }

  function computeOU(info, total) {
    const sum = info.homeScore + info.awayScore;
    if (sum > total) return "Over";
    if (sum < total) return "Under";
    return "Push";
  }

  function pickSide(pick, homeName, awayName) {
    const p = norm(pick);
    if (!p) return "";
    if (p === norm(homeName)) return "home";
    if (p === norm(awayName)) return "away";
    return "";
  }

  function extractGameIdsWide(row, nGames) {
    const ids = [];
    for (let i = 1; i <= nGames; i++) ids.push(String(row[`GameID${i}`] || "").trim());
    return ids;
  }

  function ensureEntrant(standings, name) {
    if (standings.has(name)) return;
    standings.set(name, {
      name,
      wc_adv:0,wc_ats:0,wc_ou:0,wc_total:0,
      div_adv:0,div_ats:0,div_ou:0,div_total:0,
      conf_adv:0,conf_ats:0,conf_ou:0,conf_total:0,
      sb_adv:0,sb_ats:0,sb_ou:0,
      sb_afc:0,sb_nfc:0,sb_champ:0,sb_total:0,
      total:0,
      tiebreaker:0
    });
  }

  function scoreRound(picksRows, nGames, prefix, weights, eventsById, linesById, standings) {
    picksRows.forEach(r => {
      const name = String(r.Name || "").trim();
      if (!name) return;

      ensureEntrant(standings, name);
      const s = standings.get(name);
      const gameIds = extractGameIdsWide(r, nGames);

      for (let i = 1; i <= nGames; i++) {
        const gid = gameIds[i-1];
        if (!gid) continue;

        const ev = eventsById.get(gid);
        const line = linesById.get(gid);
        if (!ev || !line) continue;

        const info = eventInfo(ev);
        if (!info.isFinal) continue;

        const advPick = String(r[`PickAdvancing${i}`] || "").trim();
        const atsPick = String(r[`PickATS${i}`] || "").trim();
        const ouPick  = String(r[`Pick OU${i}`] || "").trim();

        if (norm(advPick) && norm(advPick) === norm(info.winnerTeam)) s[`${prefix}_adv`] += weights.adv;

        if (!Number.isNaN(info.homeScore) && !Number.isNaN(info.awayScore)) {
          const { atsWinner, homeMargin } = computeATSWinnerAndHomeMargin(info, line.homeSpread);

          if (atsWinner !== "Push") {
            const side = pickSide(atsPick, info.homeName, info.awayName);
            const correctSide = (norm(atsWinner) === norm(info.homeName)) ? "home" : "away";

            if (side && side === correctSide) {
              s[`${prefix}_ats`] += weights.ats;
            } else {
              let miss = 0;
              if (side === "home") miss = Math.max(0, -homeMargin);
              else if (side === "away") miss = Math.max(0, homeMargin);
              else miss = Math.abs(homeMargin);
              s.tiebreaker += miss;
            }
          }

          const ouRes = computeOU(info, line.total);
          if (ouRes !== "Push" && norm(ouPick) && norm(ouPick) === norm(ouRes)) s[`${prefix}_ou`] += weights.ou;
        }
      }

      if (prefix === "wc")   s.wc_total   = s.wc_adv + s.wc_ats + s.wc_ou;
      if (prefix === "div")  s.div_total  = s.div_adv + s.div_ats + s.div_ou;
      if (prefix === "conf") s.conf_total = s.conf_adv + s.conf_ats + s.conf_ou;
    });
  }

  function getChampWinners(eventsById) {
    let afcWinner = "", nfcWinner = "", sbWinner = "";
    for (const ev of eventsById.values()) {
      const info = eventInfo(ev);
      if (!info.isFinal) continue;
      const title = norm(info.name);
      if (!afcWinner && title.includes("afc") && title.includes("championship")) afcWinner = info.winnerTeam;
      if (!nfcWinner && title.includes("nfc") && title.includes("championship")) nfcWinner = info.winnerTeam;
      if (!sbWinner  && title.includes("super bowl")) sbWinner = info.winnerTeam;
    }
    return { afcWinner, nfcWinner, sbWinner };
  }

  function scorePredictions(predRows, champs, standings) {
    predRows.forEach(r => {
      const name = String(r.Name || "").trim();
      if (!name) return;

      ensureEntrant(standings, name);
      const s = standings.get(name);

      const pickAFC = String(r.AFCChampion || r["AFC Champion"] || "").trim();
      const pickNFC = String(r.NFCChampion || r["NFC Champion"] || "").trim();
      const pickSB  = String(r.SuperBowlChampion || r["Super Bowl Champion"] || r.SBChampion || "").trim();

      const afcCorrect = champs.afcWinner && norm(pickAFC) === norm(champs.afcWinner);
      const nfcCorrect = champs.nfcWinner && norm(pickNFC) === norm(champs.nfcWinner);
      const sbCorrect  = champs.sbWinner  && norm(pickSB)  === norm(champs.sbWinner);

      s.sb_afc = afcCorrect ? SC.PRED.afc : 0;
      s.sb_nfc = nfcCorrect ? SC.PRED.nfc : 0;
      s._sb_both_bonus = (champs.afcWinner && champs.nfcWinner && afcCorrect && nfcCorrect) ? SC.PRED.both : 0;
      s.sb_champ = sbCorrect ? SC.PRED.champ : 0;
    });
  }

  function finalizeTotals(standings) {
    standings.forEach(s => {
      const sbPredTotal = (s.sb_afc||0) + (s.sb_nfc||0) + (s._sb_both_bonus||0) + (s.sb_champ||0);
      const sbGameTotal = (s.sb_adv||0) + (s.sb_ats||0) + (s.sb_ou||0);
      s.sb_total = sbGameTotal + sbPredTotal;
      s.total = (s.wc_total||0) + (s.div_total||0) + (s.conf_total||0) + (s.sb_total||0);
      delete s._sb_both_bonus;
    });
  }

  function renderTable(rows) {
    // Sort by Total desc, Tie-breaker asc (NO alphabetical)
    rows.sort((a,b) => (b.total - a.total) || (a.tiebreaker - b.tiebreaker));

    tbodyEl.innerHTML = "";

    let lastKey = null;
    let lastRank = 0;

    rows.forEach((r, idx) => {
      // Stable tie key (avoid float noise)
      const key = `${Number(r.total).toFixed(2)}|${Number(r.tiebreaker).toFixed(2)}`;
      const rank = (key === lastKey) ? lastRank : (idx + 1);
      lastKey = key;
      lastRank = rank;

      const tr = document.createElement("tr");
      tr.innerHTML = `
        <td>${rank}</td>
        <td class="name">${r.name}</td>

        <td>${r.wc_adv}</td>
        <td>${r.wc_ats}</td>
        <td>${r.wc_ou}</td>
        <td class="subtotal block-end">${r.wc_total}</td>

        <td class="future-round">${r.div_adv}</td>
        <td class="future-round">${r.div_ats}</td>
        <td class="future-round">${r.div_ou}</td>
        <td class="future-round subtotal block-end">${r.div_total}</td>

        <td class="future-round">${r.conf_adv}</td>
        <td class="future-round">${r.conf_ats}</td>
        <td class="future-round">${r.conf_ou}</td>
        <td class="future-round subtotal block-end">${r.conf_total}</td>

        <td class="future-round">${r.sb_adv}</td>
        <td class="future-round">${r.sb_ats}</td>
        <td class="future-round">${r.sb_ou}</td>

        <td class="future-round">${r.sb_afc}</td>
        <td class="future-round">${r.sb_nfc}</td>
        <td class="future-round">${r.sb_champ}</td>
        <td class="future-round subtotal block-end">${r.sb_total}</td>

        <td class="totalcol">${r.total}</td>
        <td class="tbcol">${Number(r.tiebreaker).toFixed(1).replace(/\.0$/, "")}</td>
      `;
      tbodyEl.appendChild(tr);
    });
  }

  // ===== Collapse future rounds (Divisional + Conference + Super Bowl) =====
  function setupFutureCollapse() {
    if (!tableEl || !tableEl.tHead) return;

    let btn = document.getElementById("toggleFuture");
    if (!btn) {
      btn = document.createElement("button");
      btn.className = "btn";
      btn.id = "toggleFuture";
      btn.type = "button";
      btn.textContent = "Show future rounds";
      const card = tableEl.closest(".card") || tableEl.parentElement;
      if (card) card.insertBefore(btn, tableEl);
      else tableEl.parentElement.insertBefore(btn, tableEl);
    }

    const futureGroupMatchers = [/divisional/i, /conference/i, /super bowl/i];

    function getFutureColumnIndices() {
      const rows = Array.from(tableEl.tHead.rows || []);
      let targetRow = null;

      for (const r of rows) {
        const cells = Array.from(r.cells || []);
        if (cells.some(c => futureGroupMatchers.some(rx => rx.test((c.textContent || "").trim())))) {
          targetRow = r;
          break;
        }
      }
      if (!targetRow) return new Set();

      const hidden = new Set();
      let col = 0;

      for (const cell of Array.from(targetRow.cells)) {
        const span = cell.colSpan || 1;
        const txt = (cell.textContent || "").trim();
        const isFuture = futureGroupMatchers.some(rx => rx.test(txt));
        if (isFuture) for (let i = col; i < col + span; i++) hidden.add(i);
        col += span;
      }
      return hidden;
    }

    const futureCols = getFutureColumnIndices();

    function applyCollapsed(collapsed) {
      const allRows = [
        ...Array.from(tableEl.tHead?.rows || []),
        ...Array.from(tableEl.tBodies?.[0]?.rows || [])
      ];

      for (const tr of allRows) {
        let col = (tr.parentElement === tableEl.tHead && tr.rowIndex === 1) ? 2 : 0;
        for (const cell of Array.from(tr.cells || [])) {
          const span = cell.colSpan || 1;
          let shouldHide = false;

          for (let i = col; i < col + span; i++) {
            if (futureCols.has(i)) { shouldHide = true; break; }
          }

          cell.classList.toggle("hidden-col", collapsed && shouldHide);
          col += span;
        }
      }

      btn.textContent = collapsed ? "Show future rounds" : "Hide future rounds";
    }

    window.__futureCollapsed = true; // default collapsed
    window.__applyFutureCollapse = applyCollapsed;

    applyCollapsed(window.__futureCollapsed);

    btn.onclick = () => {
      window.__futureCollapsed = !window.__futureCollapsed;
      applyCollapsed(window.__futureCollapsed);
    };
  }

  async function main() {
    if (!msgEl || !tbodyEl) return;

    msgEl.textContent = "Loading…";

    const [linesText, wcText, divText, confText, sbText, predText] = await Promise.all([
      fetchTextOrNull("lines.csv"),
      fetchTextOrNull("wildcard_picks.csv"),
      fetchTextOrNull("divisional_picks.csv"),
      fetchTextOrNull("conference_picks.csv"),
      fetchTextOrNull("superbowl_picks.csv"),
      fetchTextOrNull("superbowl_predictions.csv")
    ]);

    if (!linesText) { msgEl.textContent = "Missing lines.csv"; return; }
    const linesById = parseLines(linesText);

    // If scoreboard fails, still show 0’s (don’t brick the page)
    let scoreboard = { events: [] };
    try {
      scoreboard = await fetchJsonWithFallback(SCOREBOARD_URLS);
    } catch (e) {}

    const eventsById = new Map();
    (scoreboard.events || []).forEach(ev => { if (ev?.id) eventsById.set(String(ev.id), ev); });

    const standings = new Map();

    if (wcText)   scoreRound(parseCSV(wcText),   6, "wc",   SC.WC,   eventsById, linesById, standings);
    if (divText)  scoreRound(parseCSV(divText),  4, "div",  SC.DIV,  eventsById, linesById, standings);
    if (confText) scoreRound(parseCSV(confText), 2, "conf", SC.CONF, eventsById, linesById, standings);
    if (sbText)   scoreRound(parseCSV(sbText),   1, "sb",   SC.SB,   eventsById, linesById, standings);

    const champs = getChampWinners(eventsById);
    if (predText) scorePredictions(parseCSV(predText), champs, standings);

    finalizeTotals(standings);
    renderTable(Array.from(standings.values()));

    setupFutureCollapse();
    if (window.__applyFutureCollapse) window.__applyFutureCollapse(window.__futureCollapsed);

    const missing = [];
    if (!wcText) missing.push("wildcard_picks.csv");
    if (!divText) missing.push("divisional_picks.csv");
    if (!confText) missing.push("conference_picks.csv");
    if (!sbText) missing.push("superbowl_picks.csv");
    if (!predText) missing.push("superbowl_predictions.csv");

    const champBits = [
      champs.afcWinner ? `AFC: ${champs.afcWinner}` : "AFC: TBD",
      champs.nfcWinner ? `NFC: ${champs.nfcWinner}` : "NFC: TBD",
      champs.sbWinner  ? `SB: ${champs.sbWinner}`  : "SB: TBD"
    ].join(" | ");

    msgEl.textContent =
      (missing.length ? `Missing: ${missing.join(", ")}. ` : "All pick files loaded. ") + champBits;
  }

  main().catch(err => {
    console.error(err);
    if (msgEl) msgEl.textContent = "Could not load standings right now.";
  });

})();
</script>
</body>
</html>
