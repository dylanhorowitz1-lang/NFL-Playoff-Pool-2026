<!doctype html>
<html>
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Standings</title>
 <style>
  :root{
    --bg:#0b1020;
    --card:#111a33;
    --card2:#0f1730;
    --text:#e8ecff;
    --muted:#a9b3da;
    --accent:#5eead4;
    --border: rgba(255,255,255,.12);
    --shadow: 0 12px 30px rgba(0,0,0,.35);
  }
  *{box-sizing:border-box}
  body{
    margin:0;
    font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Arial, "Apple Color Emoji","Segoe UI Emoji";
    background: radial-gradient(1200px 500px at 20% -10%, rgba(94,234,212,.18), transparent 60%),
                radial-gradient(900px 500px at 100% 0%, rgba(99,102,241,.22), transparent 55%),
                var(--bg);
    color:var(--text);
    min-height:100vh;
  }
  .wrap{max-width:1200px;margin:0 auto;padding:28px 16px 44px}
  .top{
    display:flex;align-items:flex-start;justify-content:space-between;gap:16px;flex-wrap:wrap;
    padding:18px 18px 10px;border:1px solid var(--border);border-radius:18px;background:rgba(17,26,51,.55);
    box-shadow: var(--shadow); backdrop-filter: blur(10px);
  }
  h1{margin:0;font-size:28px;letter-spacing:.2px}
  .sub{margin:6px 0 0;color:var(--muted);max-width:860px;line-height:1.45}
  .pill{
    display:inline-flex;align-items:center;gap:8px;
    padding:8px 10px;border:1px solid var(--border);border-radius:999px;
    color:var(--muted);font-size:12px;background:rgba(15,23,48,.55)
  }
  .nav{
    margin-top:12px;
    display:flex;gap:10px;flex-wrap:wrap;
  }
  .btn{
    display:inline-flex;align-items:center;gap:8px;
    padding:10px 12px;border-radius:12px;
    border:1px solid var(--border);
    background: rgba(15,23,48,.65);
    color:var(--text);
    text-decoration:none;
    transition: transform .12s ease, border-color .12s ease;
  }
  .btn:hover{transform: translateY(-1px);border-color: rgba(94,234,212,.45)}
  .card{
    margin-top:18px;
    border:1px solid var(--border);
    border-radius:18px;
    background: linear-gradient(180deg, rgba(17,26,51,.75), rgba(15,23,48,.65));
    box-shadow: var(--shadow);
    padding:14px;
    overflow-x:auto;
  }

  /* Toggle support */
  .hidden-col{ display:none !important; }

  /* Table (kept, lightly themed) */
  table { border-collapse: collapse; width: 100%; min-width: 1050px; }
  th, td { border: 1px solid rgba(255,255,255,.18); padding: 6px; text-align: center; }
  th.name, td.name { text-align: left; font-weight: bold; white-space: nowrap; }
  thead th { position: sticky; top: 0; background: rgba(15,23,48,.95); z-index: 2; }

  #msg { color: var(--muted); font-size: 12px; margin-top: 10px; }
</style>
</head>
<body>
  <div class="wrap">
    <div class="top">
      <div>
        <h1>Standings</h1>
        <p class="sub">Scores update when games are final.</p>
        <div class="nav">
          <a class="btn" href="index.html">Home</a>
          <a class="btn" href="wildcard.html">Wild Card Picks</a>
          <a class="btn" href="superbowl.html">Super Bowl Predictions</a>
        </div>
      </div>
      <div class="pill">Manual refresh</div>
    </div>

    <div id="msg"></div>

    <div class="card">
      <table id="tbl">
        <thead>
          <tr>
            <th rowspan="2">Rank</th>
            <th rowspan="2" class="name">Entrant</th>

            <th colspan="4">Wild Card</th>
            <th colspan="4" class="future-round">Divisional</th>
            <th colspan="4" class="future-round">Conference Championships</th>
            <th colspan="7" class="future-round">Super Bowl</th>

            <th rowspan="2">Total</th>
            <th rowspan="2">Tie-breaker</th>
          </tr>

          <tr>
            <th>Adv</th><th>Spread</th><th>O/U</th><th>Total WC</th>
            <th class="future-round">Adv</th><th class="future-round">Spread</th><th class="future-round">O/U</th><th class="future-round">Total DIV</th>
            <th class="future-round">Adv</th><th class="future-round">Spread</th><th class="future-round">O/U</th><th class="future-round">Total CONF</th>
            <th class="future-round">Adv</th><th class="future-round">Spread</th><th class="future-round">O/U</th>
            <th class="future-round">AFC</th><th class="future-round">NFC</th><th class="future-round">SB Champ</th><th class="future-round">Total SB</th>
          </tr>
        </thead>
        <tbody id="tbody"></tbody>
      </table>
    </div>
  </div>

<script>
  const SCOREBOARD_URLS = [
    "https://api.codetabs.com/v1/proxy/?quest=" + encodeURIComponent(
      "https://site.api.espn.com/apis/site/v2/sports/football/nfl/scoreboard"
    ),
    "https://corsproxy.io/?" + encodeURIComponent(
      "https://site.api.espn.com/apis/site/v2/sports/football/nfl/scoreboard"
    )
  ];

  const SC = {
    WC:   { adv: 3,    ats: 2,   ou: 1   },
    DIV:  { adv: 4.5,  ats: 3,   ou: 1.5 },
    CONF: { adv: 9,    ats: 6,   ou: 3   },
    SB:   { adv: 13.5, ats: 9,   ou: 4.5 },
    PRED: { afc: 4.5, nfc: 4.5, both: 1.5, champ: 7.5 }
  };

  const msgEl = document.getElementById("msg");
  const tbodyEl = document.getElementById("tbody");

  function norm(s) { return String(s || "").trim().toLowerCase(); }

  function splitCSVLine(line) {
    const out = [];
    let cur = "", inQ = false;
    for (let i = 0; i < line.length; i++) {
      const ch = line[i];
      if (ch === '"') {
        if (inQ && line[i+1] === '"') { cur += '"'; i++; }
        else inQ = !inQ;
      } else if (ch === ',' && !inQ) {
        out.push(cur); cur = "";
      } else cur += ch;
    }
    out.push(cur);
    return out.map(x => x.trim());
  }

  function parseCSV(text) {
    const lines = text.replace(/\r/g, "").split("\n").filter(l => l.trim() !== "");
    if (lines.length < 2) return [];
    const headers = splitCSVLine(lines[0]);
    return lines.slice(1).map(line => {
      const cols = splitCSVLine(line);
      const obj = {};
      headers.forEach((h, i) => obj[h] = (cols[i] ?? ""));
      return obj;
    });
  }

  async function fetchJsonWithFallback(urls) {
    for (const u of urls) {
      try {
        const r = await fetch(u, { cache: "no-store" });
        if (!r.ok) continue;
        return await r.json();
      } catch (e) {}
    }
    throw new Error("Failed to fetch scoreboard");
  }

  async function fetchTextOrNull(path) {
    try {
      const r = await fetch(path, { cache: "no-store" });
      if (!r.ok) return null;
      return await r.text();
    } catch (e) { return null; }
  }

  function parseLines(linesText) {
    const rows = parseCSV(linesText);
    const map = new Map();
    rows.forEach(r => {
      const gid = String(r.GameID || "").trim();
      const hs = Number(r.HomeSpread);
      const tot = Number(r.Total);
      if (!gid || Number.isNaN(hs) || Number.isNaN(tot)) return;
      map.set(gid, { homeSpread: hs, total: tot });
    });
    return map;
  }

  function eventInfo(ev) {
    const comp = ev.competitions?.[0];
    const teams = comp?.competitors || [];
    const away = teams.find(t => t.homeAway === "away");
    const home = teams.find(t => t.homeAway === "home");

    const awayName = away?.team?.displayName || "Away";
    const homeName = home?.team?.displayName || "Home";
    const awayScore = Number(away?.score ?? NaN);
    const homeScore = Number(home?.score ?? NaN);

    const isFinal = comp?.status?.type?.completed === true;
    const winnerTeam = isFinal ? (teams.find(t => t.winner === true)?.team?.displayName || "") : "";

    return { awayName, homeName, awayScore, homeScore, isFinal, winnerTeam, name: (ev.name || ev.shortName || "") };
  }

  function computeATSWinnerAndHomeMargin(info, homeSpread) {
    const homeMargin = (info.homeScore + homeSpread) - info.awayScore;
    let winner = "Push";
    if (homeMargin > 0) winner = info.homeName;
    else if (homeMargin < 0) winner = info.awayName;
    return { atsWinner: winner, homeMargin };
  }

  function computeOU(info, total) {
    const sum = info.homeScore + info.awayScore;
    if (sum > total) return "Over";
    if (sum < total) return "Under";
    return "Push";
  }

  function pickSide(pick, homeName, awayName) {
    const p = norm(pick);
    if (!p) return "";
    if (p === norm(homeName)) return "home";
    if (p === norm(awayName)) return "away";
    return "";
  }

  function extractGameIdsWide(row, nGames) {
    const ids = [];
    for (let i = 1; i <= nGames; i++) ids.push(String(row[`GameID${i}`] || "").trim());
    return ids;
  }

  function ensureEntrant(standings, name) {
    if (standings.has(name)) return;
    standings.set(name, {
      name,
      wc_adv:0,wc_ats:0,wc_ou:0,wc_total:0,
      div_adv:0,div_ats:0,div_ou:0,div_total:0,
      conf_adv:0,conf_ats:0,conf_ou:0,conf_total:0,
      sb_adv:0,sb_ats:0,sb_ou:0,
      sb_afc:0,sb_nfc:0,sb_champ:0,sb_total:0,
      total:0,
      tiebreaker:0
    });
  }

  function scoreRound(picksRows, nGames, prefix, weights, eventsById, linesById, standings) {
    picksRows.forEach(r => {
      const name = String(r.Name || "").trim();
      if (!name) return;

      ensureEntrant(standings, name);
      const s = standings.get(name);

      const gameIds = extractGameIdsWide(r, nGames);

      for (let i = 1; i <= nGames; i++) {
        const gid = gameIds[i-1];
        if (!gid) continue;

        const ev = eventsById.get(gid);
        const line = linesById.get(gid);
        if (!ev || !line) continue;

        const info = eventInfo(ev);
        if (!info.isFinal) continue;

        const advPick = String(r[`PickAdvancing${i}`] || "").trim();
        const atsPick = String(r[`PickATS${i}`] || "").trim();
        const ouPick  = String(r[`Pick OU${i}`] || "").trim();

        if (norm(advPick) && norm(advPick) === norm(info.winnerTeam)) s[`${prefix}_adv`] += weights.adv;

        if (!Number.isNaN(info.homeScore) && !Number.isNaN(info.awayScore)) {
          const { atsWinner, homeMargin } = computeATSWinnerAndHomeMargin(info, line.homeSpread);

          if (atsWinner !== "Push") {
            const side = pickSide(atsPick, info.homeName, info.awayName);
            const correctSide = (norm(atsWinner) === norm(info.homeName)) ? "home" : "away";

            if (side && side === correctSide) {
              s[`${prefix}_ats`] += weights.ats;
            } else {
              let miss = 0;
              if (side === "home") miss = Math.max(0, -homeMargin);
              else if (side === "away") miss = Math.max(0, homeMargin);
              else miss = Math.abs(homeMargin);
              s.tiebreaker += miss;
            }
          }

          const ouRes = computeOU(info, line.total);
          if (ouRes !== "Push" && norm(ouPick) && norm(ouPick) === norm(ouRes)) s[`${prefix}_ou`] += weights.ou;
        }
      }

      if (prefix === "wc")   s.wc_total   = s.wc_adv + s.wc_ats + s.wc_ou;
      if (prefix === "div")  s.div_total  = s.div_adv + s.div_ats + s.div_ou;
      if (prefix === "conf") s.conf_total = s.conf_adv + s.conf_ats + s.conf_ou;
      if (prefix === "sb")   s.sb_game_total = (s.sb_adv||0) + (s.sb_ats||0) + (s.sb_ou||0);
    });
  }

  function getChampWinners(eventsById) {
    let afcWinner = "", nfcWinner = "", sbWinner = "";
    for (const ev of eventsById.values()) {
      const info = eventInfo(ev);
      if (!info.isFinal) continue;
      const title = norm(info.name);
      if (!afcWinner && title.includes("afc") && title.includes("championship")) afcWinner = info.winnerTeam;
      if (!nfcWinner && title.includes("nfc") && title.includes("championship")) nfcWinner = info.winnerTeam;
      if (!sbWinner  && title.includes("super bowl")) sbWinner = info.winnerTeam;
    }
    return { afcWinner, nfcWinner, sbWinner };
  }

  function scorePredictions(predRows, champs, standings) {
    predRows.forEach(r => {
      const name = String(r.Name || "").trim();
      if (!name) return;

      ensureEntrant(standings, name);
      const s = standings.get(name);

      // IMPORTANT: your CSV headers have spaces, so use bracket notation
      const pickAFC = String(r["AFC Champion"] || "").trim();
      const pickNFC = String(r["NFC Champion"] || "").trim();
      const pickSB  = String(r["Super Bowl Champion"] || "").trim();

      const afcCorrect = champs.afcWinner && norm(pickAFC) === norm(champs.afcWinner);
      const nfcCorrect = champs.nfcWinner && norm(pickNFC) === norm(champs.nfcWinner);
      const sbCorrect  = champs.sbWinner  && norm(pickSB)  === norm(champs.sbWinner);

      s.sb_afc = afcCorrect ? SC.PRED.afc : 0;
      s.sb_nfc = nfcCorrect ? SC.PRED.nfc : 0;
      s._sb_both_bonus = (champs.afcWinner && champs.nfcWinner && afcCorrect && nfcCorrect) ? SC.PRED.both : 0;
      s.sb_champ = sbCorrect ? SC.PRED.champ : 0;
    });
  }

  function finalizeTotals(standings) {
    standings.forEach(s => {
      const sbPredTotal = (s.sb_afc||0) + (s.sb_nfc||0) + (s._sb_both_bonus||0) + (s.sb_champ||0);
      const sbGameTotal = (s.sb_adv||0) + (s.sb_ats||0) + (s.sb_ou||0);
      s.sb_total = sbGameTotal + sbPredTotal;
      s.total = (s.wc_total||0) + (s.div_total||0) + (s.conf_total||0) + (s.sb_total||0);
      delete s._sb_both_bonus;
      delete s.sb_game_total;
    });
  }

  function renderTable(rows) {
    rows.sort((a,b) => (b.total - a.total) || (a.tiebreaker - b.tiebreaker) || a.name.localeCompare(b.name));
    tbodyEl.innerHTML = "";
    rows.forEach((r, idx) => {
      const tr = document.createElement("tr");
      tr.innerHTML = `
        <td>${idx + 1}</td>
        <td class="name">${r.name}</td>

        <td>${r.wc_adv}</td><td>${r.wc_ats}</td><td>${r.wc_ou}</td><td><b>${r.wc_total}</b></td>

        <td class="future-round">${r.div_adv}</td><td class="future-round">${r.div_ats}</td><td class="future-round">${r.div_ou}</td><td class="future-round"><b>${r.div_total}</b></td>
        <td class="future-round">${r.conf_adv}</td><td class="future-round">${r.conf_ats}</td><td class="future-round">${r.conf_ou}</td><td class="future-round"><b>${r.conf_total}</b></td>

        <td class="future-round">${r.sb_adv}</td><td class="future-round">${r.sb_ats}</td><td class="future-round">${r.sb_ou}</td>
        <td class="future-round">${r.sb_afc}</td><td class="future-round">${r.sb_nfc}</td><td class="future-round">${r.sb_champ}</td><td class="future-round"><b>${r.sb_total}</b></td>

        <td><b>${r.total}</b></td>
        <td>${Number(r.tiebreaker).toFixed(1).replace(/\.0$/, "")}</td>
      `;
      tbodyEl.appendChild(tr);
    });
  }

  function initCollapse() {
    // ensure hidden-col exists (in case CSS missed)
    if (!document.getElementById("collapse-css")) {
      const st = document.createElement("style");
      st.id = "collapse-css";
      st.textContent = `.hidden-col{display:none !important;}`;
      document.head.appendChild(st);
    }

    const table = document.getElementById("tbl");
    if (!table) return;

    // insert one toggle button above the table (inside the same card)
    let btn = document.getElementById("toggleFuture");
    if (!btn) {
      btn = document.createElement("button");
      btn.className = "btn";
      btn.id = "toggleFuture";
      btn.type = "button";
      btn.setAttribute("aria-pressed", "true"); // collapsed default
      btn.textContent = "Show future rounds";
      const card = table.closest(".card") || table.parentElement;
      card.insertBefore(btn, table);
    }

    function setCollapsed(collapsed) {
      document.querySelectorAll(".future-round").forEach(el => {
        el.classList.toggle("hidden-col", collapsed);
      });
      btn.setAttribute("aria-pressed", String(collapsed));
      btn.textContent = collapsed ? "Show future rounds" : "Hide future rounds";
    }

    // default collapsed
    setCollapsed(true);

    btn.addEventListener("click", () => {
      const collapsed = btn.getAttribute("aria-pressed") === "true";
      setCollapsed(!collapsed);
    });
  }

  async function main() {
    msgEl.textContent = "Loadingâ€¦";

    const [linesText, wcText, divText, confText, sbText, predText] = await Promise.all([
      fetchTextOrNull("lines.csv"),
      fetchTextOrNull("wildcard_picks.csv"),
      fetchTextOrNull("divisional_picks.csv"),
      fetchTextOrNull("conference_picks.csv"),
      fetchTextOrNull("superbowl_picks.csv"),
      fetchTextOrNull("superbowl_predictions.csv")
    ]);

    if (!linesText) { msgEl.textContent = "Missing lines.csv"; return; }
    const linesById = parseLines(linesText);

    const scoreboard = await fetchJsonWithFallback(SCOREBOARD_URLS);
    const eventsById = new Map();
    (scoreboard.events || []).forEach(ev => { if (ev?.id) eventsById.set(String(ev.id), ev); });

    const standings = new Map();

    if (wcText)   scoreRound(parseCSV(wcText),   6, "wc",   SC.WC,   eventsById, linesById, standings);
    if (divText)  scoreRound(parseCSV(divText),  4, "div",  SC.DIV,  eventsById, linesById, standings);
    if (confText) scoreRound(parseCSV(confText), 2, "conf", SC.CONF, eventsById, linesById, standings);
    if (sbText)   scoreRound(parseCSV(sbText),   1, "sb",   SC.SB,   eventsById, linesById, standings);

    const champs = getChampWinners(eventsById);
    if (predText) scorePredictions(parseCSV(predText), champs, standings);

    finalizeTotals(standings);
    renderTable(Array.from(standings.values()));
    initCollapse();

    const missing = [];
    if (!wcText) missing.push("wildcard_picks.csv");
    if (!divText) missing.push("divisional_picks.csv");
    if (!confText) missing.push("conference_picks.csv");
    if (!sbText) missing.push("superbowl_picks.csv");
    if (!predText) missing.push("superbowl_predictions.csv");

    const champBits = [
      champs.afcWinner ? `AFC: ${champs.afcWinner}` : "AFC: TBD",
      champs.nfcWinner ? `NFC: ${champs.nfcWinner}` : "NFC: TBD",
      champs.sbWinner  ? `SB: ${champs.sbWinner}`  : "SB: TBD"
    ].join(" | ");

    msgEl.textContent =
      (missing.length ? `Missing: ${missing.join(", ")}. ` : "All pick files loaded. ")
      + champBits;
  }

  main().catch(err => {
    console.error(err);
    msgEl.textContent = "Could not load standings right now.";
  });
</script>
</body>
</html>
