<html>
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Standings</title>
  <style>
    :root{
      --bg:#0b1020;
      --card:#111a33;
      --card2:#0f1730;
      --text:#e8ecff;
      --muted:#a9b3da;
      --accent:#5eead4;
      --border: rgba(255,255,255,.12);
      --shadow: 0 12px 30px rgba(0,0,0,.35);

      --grid: rgba(255,255,255,.18);
      --sep: rgba(255,255,255,.22);
      --totalBorder: rgba(255,255,255,.40);
      --subtotalTint: rgba(94,234,212,.10);
      --totalTint: rgba(99,102,241,.16);

      /* JS will set this to the exact pixel height of header row #1 */
      --standingsHeadOffset: 40px;
    }
    *{box-sizing:border-box}
    body{
      margin:0;
      font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Arial, "Apple Color Emoji","Segoe UI Emoji";
      background: radial-gradient(1200px 500px at 20% -10%, rgba(94,234,212,.18), transparent 60%),
                  radial-gradient(900px 500px at 100% 0%, rgba(99,102,241,.22), transparent 55%),
                  var(--bg);
      color:var(--text);
      min-height:100vh;
    }
    .wrap{max-width:1200px;margin:0 auto;padding:28px 16px 44px}
    .top{
      display:flex;align-items:flex-start;justify-content:space-between;gap:16px;flex-wrap:wrap;
      padding:18px 18px 10px;border:1px solid var(--border);border-radius:18px;background:rgba(17,26,51,.55);
      box-shadow: var(--shadow); backdrop-filter: blur(10px);
    }
    h1{margin:0;font-size:28px;letter-spacing:.2px}
    .sub{margin:6px 0 0;color:var(--muted);max-width:860px;line-height:1.45}
    .pill{
      display:inline-flex;align-items:center;gap:8px;
      padding:8px 10px;border:1px solid var(--border);border-radius:999px;
      color:var(--muted);font-size:12px;background:rgba(15,23,48,.55)
    }
    .nav{margin-top:12px;display:flex;gap:10px;flex-wrap:wrap;}
    .btn{
      display:inline-flex;align-items:center;gap:8px;
      padding:10px 12px;border-radius:12px;
      border:1px solid var(--border);
      background: rgba(15,23,48,.65);
      color:var(--text);
      text-decoration:none;
      transition: transform .12s ease, border-color .12s ease;
      cursor:pointer;
    }
    .btn:hover{transform: translateY(-1px);border-color: rgba(94,234,212,.45)}
    .card{
      margin-top:18px;border:1px solid var(--border);border-radius:18px;
      background: linear-gradient(180deg, rgba(17,26,51,.75), rgba(15,23,48,.65));
      box-shadow: var(--shadow);padding:14px;overflow-x:auto;
    }

    /* ===== TABLE ===== */
    #tbl{
      border-collapse: collapse;
      width: 100%;
      min-width: 1200px;
      table-layout: fixed;
    }
    #tbl th, #tbl td{
      border: 1px solid var(--grid);
      padding: 7px 8px;
      text-align: center;
      vertical-align: middle;
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
      font-size: 13px;
    }
    #tbl th.name, #tbl td.name{
      text-align: left;
      font-weight: 700;
      white-space: nowrap;
    }

    /* --- 2-row sticky header fix --- */
    #tbl thead th{
      position: sticky;
      background: rgba(15,23,48,.95);
      z-index: 5;
    }
    #tbl thead tr:nth-child(1) th{
      top: 0;
      z-index: 6;
    }
    #tbl thead tr:nth-child(2) th{
      top: var(--standingsHeadOffset);
      z-index: 5;
    }

    #tbl col.c-rank{ width: 44px; }
    #tbl col.c-name{ width: 180px; }

    #tbl col.c-adv{ width: 72px; }
    #tbl col.c-spread{ width: 72px; }
    #tbl col.c-ou{ width: 54px; }

    #tbl col.c-subtotal{ width: 70px; }
    #tbl col.c-pred{ width: 78px; }
    #tbl col.c-total{ width: 82px; }
    #tbl col.c-tb{ width: 60px; }

    .block-end{
      border-right: 2px solid var(--sep) !important;
    }

    .subtotal{
      background: var(--subtotalTint);
      font-weight: 800;
    }

    .totalcol{
      background: var(--totalTint);
      font-weight: 900;
      border-left: 3px solid var(--totalBorder) !important;
      border-right: 3px solid var(--totalBorder) !important;
    }
    #tbl thead .totalcol{ border-top: 3px solid var(--totalBorder) !important; }
    #tbl tbody tr:last-child .totalcol{ border-bottom: 3px solid var(--totalBorder) !important; }

    .tbcol{
      font-size: 12px;
      color: rgba(232,236,255,.85);
    }

    #msg{ color:var(--muted); font-size:12px; margin-top:10px; }

    #tbl thead th:first-child,
    #tbl tbody td:first-child {
      width: 60px;
    }
  </style>
</head>
<body>
  <div class="wrap">
    <div class="top">
      <div>
        <h1>Standings</h1>
        <p class="sub">Scores update when games are final.</p>
        <div class="nav">
          <a class="btn" href="index.html">Home</a>
          <a class="btn" href="Winner_Scenarios.html">Winner Scenarios</a>

        </div>
      </div>
      <div class="pill">Manual refresh</div>
    </div>

    <div id="msg"></div>

    <div class="card">
      <table id="tbl">
        <colgroup>
          <col class="c-rank">
          <col class="c-name">

          <col class="c-adv"><col class="c-spread"><col class="c-ou"><col class="c-subtotal">
          <col class="c-adv"><col class="c-spread"><col class="c-ou"><col class="c-subtotal">
          <col class="c-adv"><col class="c-spread"><col class="c-ou"><col class="c-subtotal">

          <col class="c-adv"><col class="c-spread"><col class="c-ou">
          <col class="c-pred"><col class="c-pred"><col class="c-pred"><col class="c-pred"><col class="c-subtotal">

          <col class="c-total"><col class="c-tb">
        </colgroup>

        <thead>
          <tr id="standingsHeadRow1">
            <th rowspan="2">Rank</th>
            <th rowspan="2" class="name">Entrant</th>

            <th colspan="4">Wild Card</th>
            <th colspan="4">Divisional</th>
            <th colspan="4">Conference Championships</th>
            <th colspan="8">Super Bowl</th>

            <th rowspan="2" class="totalcol">Total</th>
            <th rowspan="2" class="tbcol">Tie-breaker</th>
          </tr>

          <tr>
            <th>Adv</th><th>Spread</th><th>O/U</th><th class="subtotal block-end">Total</th>
            <th>Adv</th><th>Spread</th><th>O/U</th><th class="subtotal block-end">Total</th>
            <th>Adv</th><th>Spread</th><th>O/U</th><th class="subtotal block-end">Total</th>

            <th>Adv</th><th>Spread</th><th>O/U</th>
            <th>AFC</th><th>NFC</th><th>Bonus</th><th>SB Champ</th><th class="subtotal block-end">Total</th>
          </tr>
        </thead>

        <tbody id="tbody"></tbody>
      </table>
    </div>
  </div>

<script>
(() => {
  "use strict";

  const SCOREBOARD_URLS = [
    "https://api.codetabs.com/v1/proxy/?quest=" + encodeURIComponent(
      "https://site.api.espn.com/apis/site/v2/sports/football/nfl/scoreboard"
    ),
    "https://corsproxy.io/?" + encodeURIComponent(
      "https://site.api.espn.com/apis/site/v2/sports/football/nfl/scoreboard"
    )
  ];

  function summaryUrlsForGame(gid){
    const base = "https://site.api.espn.com/apis/site/v2/sports/football/nfl/summary?event=" + encodeURIComponent(gid);
    return [
      "https://api.codetabs.com/v1/proxy/?quest=" + encodeURIComponent(base),
      "https://corsproxy.io/?" + encodeURIComponent(base)
    ];
  }

  const SC = {
    WC:   { adv: 3,    ats: 2,   ou: 1   },
    DIV:  { adv: 4.5,  ats: 3,   ou: 1.5 },
    CONF: { adv: 9,    ats: 6,   ou: 3   },
    SB:   { adv: 13.5, ats: 9,   ou: 4.5 },
    PRED: { afc: 4.5, nfc: 4.5, both: 1.5, champ: 7.5 }
  };

  // ==========================================================
  // MANUAL OVERRIDE (rarely needed)
  // Leave these blank ("") to stay fully automatic.
  // If BOTH ESPN + superbowl.html ever fail, set these to the
  // exact team display names to force prediction scoring.
  // ==========================================================
  const MANUAL_CHAMPS = {
    afc: "New England Patriots",  // e.g. "Kansas City Chiefs"
    nfc: "Seattle Seahawks",  // e.g. "Philadelphia Eagles"
    sb:  ""   // e.g. "Kansas City Chiefs"
  };

  const msgEl = document.getElementById("msg");
  const tbodyEl = document.getElementById("tbody");

  function setStickyOffset(){
    const r1 = document.getElementById("standingsHeadRow1");
    if (!r1) return;
    const h = Math.ceil(r1.getBoundingClientRect().height);
    document.documentElement.style.setProperty("--standingsHeadOffset", h + "px");
  }

  function norm(s) { return String(s || "").trim().toLowerCase(); }

  function splitCSVLine(line) {
    const out = [];
    let cur = "", inQ = false;
    for (let i = 0; i < line.length; i++) {
      const ch = line[i];
      if (ch === '"') {
        if (inQ && line[i+1] === '"') { cur += '"'; i++; }
        else inQ = !inQ;
      } else if (ch === ',' && !inQ) {
        out.push(cur); cur = "";
      } else cur += ch;
    }
    out.push(cur);
    return out.map(x => x.trim());
  }

  function parseCSV(text) {
    const lines = text.replace(/\r/g, "").split("\n").filter(l => l.trim() !== "");
    if (lines.length < 2) return [];
    const headers = splitCSVLine(lines[0]);
    return lines.slice(1).map(line => {
      const cols = splitCSVLine(line);
      const obj = {};
      headers.forEach((h, i) => obj[h] = (cols[i] ?? ""));
      return obj;
    });
  }

  async function fetchJsonWithFallback(urls) {
    for (const u of urls) {
      try {
        const r = await fetch(u, { cache: "no-store" });
        if (!r.ok) continue;
        return await r.json();
      } catch (e) {}
    }
    throw new Error("Failed to fetch JSON");
  }

  async function fetchTextOrNull(path) {
    try {
      const r = await fetch(path, { cache: "no-store" });
      if (!r.ok) return null;
      return await r.text();
    } catch (e) { return null; }
  }

  function parseLines(linesText) {
    const rows = parseCSV(linesText);
    const map = new Map();
    rows.forEach(r => {
      const gid = String(r.GameID || r.GAMEID || r.gameid || "").trim();
      const hs = Number(r.HomeSpread ?? r.homespread);
      const tot = Number(r.Total ?? r.total);
      if (!gid || Number.isNaN(hs) || Number.isNaN(tot)) return;
      map.set(gid, { homeSpread: hs, total: tot });
    });
    return map;
  }

  function getCompetition(ev){
    if (ev?.competitions?.[0]) return ev.competitions[0];
    if (ev?.header?.competitions?.[0]) return ev.header.competitions[0];
    return null;
  }

  function eventInfo(ev) {
    const comp = getCompetition(ev);
    const teams = comp?.competitors || [];
    const away = teams.find(t => t.homeAway === "away");
    const home = teams.find(t => t.homeAway === "home");

    const awayName = away?.team?.displayName || "Away";
    const homeName = home?.team?.displayName || "Home";
    const awayScore = Number(away?.score ?? NaN);
    const homeScore = Number(home?.score ?? NaN);

    const isFinal = comp?.status?.type?.completed === true;
    const winnerTeam = isFinal ? (teams.find(t => t.winner === true)?.team?.displayName || "") : "";
    return { awayName, homeName, awayScore, homeScore, isFinal, winnerTeam };
  }

  function computeATSWinnerAndHomeMargin(info, homeSpread) {
    const homeMargin = (info.homeScore + homeSpread) - info.awayScore;
    let winner = "Push";
    if (homeMargin > 0) winner = info.homeName;
    else if (homeMargin < 0) winner = info.awayName;
    return { atsWinner: winner, homeMargin };
  }

  function computeOU(info, total) {
    const sum = info.homeScore + info.awayScore;
    if (sum > total) return "Over";
    if (sum < total) return "Under";
    return "Push";
  }

  function pickSide(pick, homeName, awayName) {
    const p = norm(pick);
    if (!p) return "";
    if (p === norm(homeName)) return "home";
    if (p === norm(awayName)) return "away";
    return "";
  }

  function extractGameIdsWide(row, nGames) {
    const ids = [];
    for (let i = 1; i <= nGames; i++) ids.push(String(row[`GameID${i}`] || "").trim());
    return ids;
  }

  function ensureEntrant(standings, name) {
    if (standings.has(name)) return;
    standings.set(name, {
      name,
      wc_adv:0,wc_ats:0,wc_ou:0,wc_total:0,
      div_adv:0,div_ats:0,div_ou:0,div_total:0,
      conf_adv:0,conf_ats:0,conf_ou:0,conf_total:0,
      sb_adv:0,sb_ats:0,sb_ou:0,
      sb_afc:0,sb_nfc:0,sb_both:0,sb_champ:0,sb_total:0,
      total:0,
      tiebreaker:0
    });
  }

  function scoreRound(picksRows, nGames, prefix, weights, eventsById, linesById, standings) {
    picksRows.forEach(r => {
      const name = String(r.Name || "").trim();
      if (!name) return;

      ensureEntrant(standings, name);
      const s = standings.get(name);
      const gameIds = extractGameIdsWide(r, nGames);

      for (let i = 1; i <= nGames; i++) {
        const gid = gameIds[i-1];
        if (!gid) continue;

        const ev = eventsById.get(gid);
        const line = linesById.get(gid);
        if (!ev || !line) continue;

        const info = eventInfo(ev);
        if (!info.isFinal) continue;

        const advPick = String(r[`PickAdvancing${i}`] || "").trim();
        const atsPick = String(r[`PickATS${i}`] || "").trim();
        const ouPick  = String(r[`Pick OU${i}`] || "").trim();

        if (norm(advPick) && norm(advPick) === norm(info.winnerTeam)) s[`${prefix}_adv`] += weights.adv;

        if (!Number.isNaN(info.homeScore) && !Number.isNaN(info.awayScore)) {
          const { atsWinner, homeMargin } = computeATSWinnerAndHomeMargin(info, line.homeSpread);

          if (atsWinner !== "Push") {
            const side = pickSide(atsPick, info.homeName, info.awayName);
            const correctSide = (norm(atsWinner) === norm(info.homeName)) ? "home" : "away";

            if (side && side === correctSide) {
              s[`${prefix}_ats`] += weights.ats;
            } else {
              let miss = 0;
              if (side === "home") miss = Math.max(0, -homeMargin);
              else if (side === "away") miss = Math.max(0, homeMargin);
              else miss = Math.abs(homeMargin);
              s.tiebreaker += miss;
            }
          }

          const ouRes = computeOU(info, line.total);
          if (ouRes !== "Push" && norm(ouPick) && norm(ouPick) === norm(ouRes)) s[`${prefix}_ou`] += weights.ou;
        }
      }

      if (prefix === "wc")   s.wc_total   = s.wc_adv + s.wc_ats + s.wc_ou;
      if (prefix === "div")  s.div_total  = s.div_adv + s.div_ats + s.div_ou;
      if (prefix === "conf") s.conf_total = s.conf_adv + s.conf_ats + s.conf_ou;
    });
  }

  function getChampWinners(eventsById) {
    let afcWinner = "", nfcWinner = "", sbWinner = "";

    function eventSearchText(ev){
      const comp = getCompetition(ev);
      const notes = comp?.notes || [];
      const bits = [
        ev?.name, ev?.shortName,
        ev?.header?.name, ev?.header?.shortName,
        ev?.week?.text,
        ev?.season?.type?.name, ev?.season?.type?.slug,
        ...notes.map(n => n?.headline),
        ...notes.map(n => n?.type),
        ...notes.map(n => n?.note),
        ...notes.map(n => n?.text),
      ].filter(Boolean);
      return bits.join(" | ").toLowerCase();
    }

    for (const ev of eventsById.values()) {
      const info = eventInfo(ev);
      if (!info.isFinal) continue;

      const txt = eventSearchText(ev);

      if (!afcWinner && (txt.includes("afc championship") || txt.includes("afc championship game"))) {
        afcWinner = info.winnerTeam;
      }
      if (!nfcWinner && (txt.includes("nfc championship") || txt.includes("nfc championship game"))) {
        nfcWinner = info.winnerTeam;
      }
      if (!sbWinner && (txt.includes("super bowl") || txt.includes("superbowl"))) {
        sbWinner = info.winnerTeam;
      }
    }

    return { afcWinner, nfcWinner, sbWinner };
  }

  // ---- NEW: fallback to superbowl.html "ACTUAL" block if ESPN detection is blank ----
  async function fetchActualFromSuperbowlPage() {
    const html = await fetchTextOrNull("superbowl.html");
    if (!html) return null;

    // Expect: const ACTUAL = { afc: "...", nfc: "...", sb: "..." };
    const m = html.match(/const\s+ACTUAL\s*=\s*\{[\s\S]*?\};/);
    if (!m) return null;
    const block = m[0];

    const pick = (key) => {
      const re = new RegExp(key + String.raw`\s*:\s*("([^"\\]*(?:\\.[^"\\]*)*)"|'([^'\\]*(?:\\.[^'\\]*)*)')`);
      const mm = block.match(re);
      if (!mm) return "";
      const raw = (mm[2] ?? mm[3] ?? "");
      return raw
        .replace(/\\n/g, "\n")
        .replace(/\\"/g, '"')
        .replace(/\\'/g, "'");
    };

    return {
      afcWinner: pick("afc").trim(),
      nfcWinner: pick("nfc").trim(),
      sbWinner:  pick("sb").trim()
    };
  }

  async function getChampsAuto(eventsById) {
    // 1) ESPN attempt
    const champs = getChampWinners(eventsById);

    // 2) If missing, fallback to superbowl.html
    if (!champs.afcWinner || !champs.nfcWinner || !champs.sbWinner) {
      const fromPage = await fetchActualFromSuperbowlPage();
      if (fromPage) {
        if (!champs.afcWinner && fromPage.afcWinner) champs.afcWinner = fromPage.afcWinner;
        if (!champs.nfcWinner && fromPage.nfcWinner) champs.nfcWinner = fromPage.nfcWinner;
        if (!champs.sbWinner  && fromPage.sbWinner)  champs.sbWinner  = fromPage.sbWinner;
      }
    }

    // 3) LAST resort manual override (normally blank)
    if (MANUAL_CHAMPS.afc) champs.afcWinner = MANUAL_CHAMPS.afc;
    if (MANUAL_CHAMPS.nfc) champs.nfcWinner = MANUAL_CHAMPS.nfc;
    if (MANUAL_CHAMPS.sb)  champs.sbWinner  = MANUAL_CHAMPS.sb;

    return champs;
  }

  function scorePredictions(predRows, champs, standings) {
    predRows.forEach(r => {
      const name = String(r.Name || "").trim();
      if (!name) return;

      ensureEntrant(standings, name);
      const s = standings.get(name);

      const pickAFC = String(r.AFCChampion || r["AFC Champion"] || "").trim();
      const pickNFC = String(r.NFCChampion || r["NFC Champion"] || "").trim();
      const pickSB  = String(r.SuperBowlChampion || r["Super Bowl Champion"] || r.SBChampion || "").trim();

      const afcCorrect = champs.afcWinner && norm(pickAFC) === norm(champs.afcWinner);
      const nfcCorrect = champs.nfcWinner && norm(pickNFC) === norm(champs.nfcWinner);
      const sbCorrect  = champs.sbWinner  && norm(pickSB)  === norm(champs.sbWinner);

      s.sb_afc = afcCorrect ? SC.PRED.afc : 0;
      s.sb_nfc = nfcCorrect ? SC.PRED.nfc : 0;
      s.sb_both = (champs.afcWinner && champs.nfcWinner && afcCorrect && nfcCorrect) ? SC.PRED.both : 0;
      s.sb_champ = sbCorrect ? SC.PRED.champ : 0;
    });
  }

  function finalizeTotals(standings) {
    standings.forEach(s => {
      const sbPredTotal = (s.sb_afc||0) + (s.sb_nfc||0) + (s.sb_both||0) + (s.sb_champ||0);
      const sbGameTotal = (s.sb_adv||0) + (s.sb_ats||0) + (s.sb_ou||0);
      s.sb_total = sbGameTotal + sbPredTotal;
      s.total = (s.wc_total||0) + (s.div_total||0) + (s.conf_total||0) + (s.sb_total||0);
    });
  }

  function renderTable(rows) {
    rows.sort((a,b) => (b.total - a.total) || (a.tiebreaker - b.tiebreaker));
    tbodyEl.innerHTML = "";

    let lastKey = null;
    let lastRank = 0;

    rows.forEach((r, idx) => {
      const key = `${Number(r.total).toFixed(2)}|${Number(r.tiebreaker).toFixed(2)}`;
      const rank = (key === lastKey) ? lastRank : (idx + 1);
      lastKey = key;
      lastRank = rank;

      const tr = document.createElement("tr");
      tr.innerHTML = `
        <td>${rank}</td>
        <td class="name">${r.name}</td>

        <td>${r.wc_adv}</td>
        <td>${r.wc_ats}</td>
        <td>${r.wc_ou}</td>
        <td class="subtotal block-end">${r.wc_total}</td>

        <td>${r.div_adv}</td>
        <td>${r.div_ats}</td>
        <td>${r.div_ou}</td>
        <td class="subtotal block-end">${r.div_total}</td>

        <td>${r.conf_adv}</td>
        <td>${r.conf_ats}</td>
        <td>${r.conf_ou}</td>
        <td class="subtotal block-end">${r.conf_total}</td>

        <td>${r.sb_adv}</td>
        <td>${r.sb_ats}</td>
        <td>${r.sb_ou}</td>

        <td>${r.sb_afc}</td>
        <td>${r.sb_nfc}</td>
        <td>${r.sb_both}</td>
        <td>${r.sb_champ}</td>
        <td class="subtotal block-end">${r.sb_total}</td>

        <td class="totalcol">${r.total}</td>
        <td class="tbcol">${Number(r.tiebreaker).toFixed(1).replace(/\.0$/, "")}</td>
      `;
      tbodyEl.appendChild(tr);
    });
  }

  function collectNeededGameIds(wcRows, divRows, confRows, sbRows){
    const needed = new Set();
    const addFrom = (rows, nGames) => {
      (rows || []).forEach(r => {
        const ids = extractGameIdsWide(r, nGames);
        ids.forEach(id => { if (id) needed.add(String(id)); });
      });
    };
    addFrom(wcRows, 6);
    addFrom(divRows, 4);
    addFrom(confRows, 2);
    addFrom(sbRows, 1);
    return needed;
  }

  async function hydrateMissingEvents(eventsById, neededIds){
    const missing = [];
    neededIds.forEach(gid => {
      if (!eventsById.has(String(gid))) missing.push(String(gid));
    });
    if (!missing.length) return;

    await Promise.all(missing.map(async (gid) => {
      try {
        const data = await fetchJsonWithFallback(summaryUrlsForGame(gid));
        eventsById.set(String(gid), data);
      } catch (e) {}
    }));
  }

  async function main() {
    msgEl.textContent = "Loadingâ€¦";

    requestAnimationFrame(setStickyOffset);
    window.addEventListener("resize", () => requestAnimationFrame(setStickyOffset));

    const [linesText, wcText, divText, confText, sbText, predText] = await Promise.all([
      fetchTextOrNull("lines.csv"),
      fetchTextOrNull("wildcard_picks.csv"),
      fetchTextOrNull("divisional_picks.csv"),
      fetchTextOrNull("conference_picks.csv"),
      fetchTextOrNull("superbowl_picks.csv"),
      fetchTextOrNull("superbowl_predictions.csv")
    ]);

    if (!linesText) { msgEl.textContent = "Missing lines.csv"; return; }
    const linesById = parseLines(linesText);

    const wcRows   = wcText   ? parseCSV(wcText)   : [];
    const divRows  = divText  ? parseCSV(divText)  : [];
    const confRows = confText ? parseCSV(confText) : [];
    const sbRows   = sbText   ? parseCSV(sbText)   : [];
    const predRows = predText ? parseCSV(predText) : [];

    let scoreboard = { events: [] };
    try {
      scoreboard = await fetchJsonWithFallback(SCOREBOARD_URLS);
    } catch (e) {}

    const eventsById = new Map();
    (scoreboard.events || []).forEach(ev => { if (ev?.id) eventsById.set(String(ev.id), ev); });

    const neededIds = collectNeededGameIds(wcRows, divRows, confRows, sbRows);
    await hydrateMissingEvents(eventsById, neededIds);

    const standings = new Map();

    if (wcRows.length)   scoreRound(wcRows,   6, "wc",   SC.WC,   eventsById, linesById, standings);
    if (divRows.length)  scoreRound(divRows,  4, "div",  SC.DIV,  eventsById, linesById, standings);
    if (confRows.length) scoreRound(confRows, 2, "conf", SC.CONF, eventsById, linesById, standings);
    if (sbRows.length)   scoreRound(sbRows,   1, "sb",   SC.SB,   eventsById, linesById, standings);

    const champs = await getChampsAuto(eventsById);
    if (predRows.length) scorePredictions(predRows, champs, standings);

    finalizeTotals(standings);
    renderTable(Array.from(standings.values()));

    const missingFiles = [];
    if (!wcText) missingFiles.push("wildcard_picks.csv");
    if (!divText) missingFiles.push("divisional_picks.csv");
    if (!confText) missingFiles.push("conference_picks.csv");
    if (!sbText) missingFiles.push("superbowl_picks.csv");
    if (!predText) missingFiles.push("superbowl_predictions.csv");

    const champBits = [
      champs.afcWinner ? `AFC: ${champs.afcWinner}` : "AFC: TBD",
      champs.nfcWinner ? `NFC: ${champs.nfcWinner}` : "NFC: TBD",
      champs.sbWinner  ? `SB: ${champs.sbWinner}`  : "SB: TBD"
    ].join(" | ");

    msgEl.textContent =
      (missingFiles.length ? `Missing: ${missingFiles.join(", ")}. ` : "All pick files loaded. ") + champBits;
  }

  main().catch(err => {
    console.error(err);
    if (msgEl) msgEl.textContent = "Could not load standings right now.";
  });

})();
</script>
</body>
</html>
