<!doctype html>
<html>
<head>
  <meta charset="utf-8" />
  <title>Wild Card Picks</title>
  <style>
    table { border-collapse: collapse; width: 100%; }
    th, td { border: 1px solid #000; padding: 6px; text-align: center; }
    th.name, td.name { text-align: left; font-weight: bold; white-space: nowrap; }

    .pending { background: #e7e6e6; }   /* gray */
    .correct { background: #c6efce; }   /* green */
    .wrong   { background: #ffc7ce; }   /* red */
    .push    { background: #fff2cc; }   /* yellow */

    .small { font-size: 12px; opacity: 0.85; }
  </style>
</head>
<body>
  <h1>Wild Card Picks</h1>
  <p><a href="index.html">Home</a></p>

  <div id="msg" class="small" style="margin: 8px 0;"></div>

  <table id="picksTable">
    <thead id="thead"></thead>
    <tbody id="tbody"></tbody>
  </table>

<script>
  // Live scoreboard via proxy fallback (GitHub Pages friendly)
  const SCOREBOARD_URLS = [
    "https://api.codetabs.com/v1/proxy/?quest=" + encodeURIComponent(
      "https://site.api.espn.com/apis/site/v2/sports/football/nfl/scoreboard"
    ),
    "https://corsproxy.io/?" + encodeURIComponent(
      "https://site.api.espn.com/apis/site/v2/sports/football/nfl/scoreboard"
    )
  ];

  const msgEl = document.getElementById("msg");
  const theadEl = document.getElementById("thead");
  const tbodyEl = document.getElementById("tbody");

  function norm(s) { return String(s || "").trim().toLowerCase(); }

  function splitCSVLine(line) {
    // Minimal quoted CSV support
    const out = [];
    let cur = "", inQ = false;
    for (let i = 0; i < line.length; i++) {
      const ch = line[i];
      if (ch === '"' ) {
        if (inQ && line[i+1] === '"') { cur += '"'; i++; }
        else inQ = !inQ;
      } else if (ch === ',' && !inQ) {
        out.push(cur); cur = "";
      } else {
        cur += ch;
      }
    }
    out.push(cur);
    return out.map(x => x.trim());
  }

  function parseCSV(text) {
    const lines = text.replace(/\r/g, "").split("\n").filter(l => l.trim() !== "");
    if (lines.length < 2) return [];
    const headers = splitCSVLine(lines[0]);
    return lines.slice(1).map(line => {
      const cols = splitCSVLine(line);
      const obj = {};
      headers.forEach((h, i) => obj[h] = (cols[i] ?? ""));
      return obj;
    });
  }

  async function fetchJsonWithFallback(urls) {
    for (const u of urls) {
      try {
        const r = await fetch(u, { cache: "no-store" });
        if (!r.ok) continue;
        return await r.json();
      } catch (e) {}
    }
    throw new Error("Failed to fetch scoreboard");
  }

  async function fetchTextOrNull(path) {
    try {
      const r = await fetch(path, { cache: "no-store" });
      if (!r.ok) return null;
      return await r.text();
    } catch (e) { return null; }
  }

  function parseLines(linesText) {
    // lines.csv headers: GameID,HomeSpread,Total
    const rows = parseCSV(linesText);
    const map = new Map(); // GameID -> { homeSpread, total }
    rows.forEach(r => {
      const gid = String(r.GameID || "").trim();
      const hs = Number(r.HomeSpread);
      const tot = Number(r.Total);
      if (!gid || Number.isNaN(hs) || Number.isNaN(tot)) return;
      map.set(gid, { homeSpread: hs, total: tot });
    });
    return map;
  }

  function eventToInfo(ev) {
    const comp = ev.competitions?.[0];
    const teams = comp?.competitors || [];
    const away = teams.find(t => t.homeAway === "away");
    const home = teams.find(t => t.homeAway === "home");

    const awayName = away?.team?.displayName || "Away";
    const homeName = home?.team?.displayName || "Home";

    const awayScore = Number(away?.score ?? NaN);
    const homeScore = Number(home?.score ?? NaN);

    const isFinal = comp?.status?.type?.completed === true;
    const winnerTeam = isFinal ? (teams.find(t => t.winner === true)?.team?.displayName || "") : "";

    return { awayName, homeName, awayScore, homeScore, isFinal, winnerTeam };
  }

  function matchupLabel(info) {
    return `${info.awayName} @ ${info.homeName}`;
  }

  function computeATSWinner(info, homeSpread) {
    const adjHome = info.homeScore + homeSpread;
    if (adjHome > info.awayScore) return info.homeName;
    if (adjHome < info.awayScore) return info.awayName;
    return "Push";
  }

  function computeOUResult(info, total) {
    const sum = info.homeScore + info.awayScore;
    if (sum > total) return "Over";
    if (sum < total) return "Under";
    return "Push";
  }

  function buildHeaders(matchups) {
    // Row 1: matchups
    let row1 = `<tr><th class="name" rowspan="3">Name</th>`;
    matchups.forEach(m => row1 += `<th colspan="3">${m}</th>`);
    row1 += `</tr>`;

    // Row 2: results row (aligned)
    let row2 = `<tr>`;
    for (let i = 1; i <= 6; i++) {
      row2 += `
        <td class="pending" id="res_adv_${i}">TBD</td>
        <td class="pending" id="res_ats_${i}">TBD</td>
        <td class="pending" id="res_ou_${i}">TBD</td>
      `;
    }
    row2 += `</tr>`;

    // Row 3: subheaders
    let row3 = `<tr>`;
    for (let i = 1; i <= 6; i++) row3 += `<th>Adv</th><th>Spread</th><th>O/U</th>`;
    row3 += `</tr>`;

    theadEl.innerHTML = row1 + row2 + row3;
  }

  function setResultsCell(id, text, cls) {
    const el = document.getElementById(id);
    if (!el) return;
    el.textContent = text;
    el.className = cls || "";
  }

  function renderResults(gameIds, eventsById, linesById) {
    for (let i = 1; i <= 6; i++) {
      const gid = gameIds[i-1];
      const ev = eventsById.get(gid);
      if (!gid || !ev) {
        setResultsCell(`res_adv_${i}`, "TBD", "pending");
        setResultsCell(`res_ats_${i}`, "TBD", "pending");
        setResultsCell(`res_ou_${i}`,  "TBD", "pending");
        continue;
      }

      const info = eventToInfo(ev);

      if (!info.isFinal) {
        setResultsCell(`res_adv_${i}`, "TBD", "pending");
        setResultsCell(`res_ats_${i}`, "TBD", "pending");
        setResultsCell(`res_ou_${i}`,  "TBD", "pending");
        continue;
      }

      setResultsCell(`res_adv_${i}`, info.winnerTeam || "Final", "");

      const line = linesById.get(gid);
      if (!line || Number.isNaN(info.homeScore) || Number.isNaN(info.awayScore)) {
        setResultsCell(`res_ats_${i}`, "Line missing", "pending");
        setResultsCell(`res_ou_${i}`,  "Line missing", "pending");
        continue;
      }

      const atsWinner = computeATSWinner(info, line.homeSpread);
      const ouRes = computeOUResult(info, line.total);

      setResultsCell(`res_ats_${i}`, atsWinner, "");
      setResultsCell(`res_ou_${i}`,  ouRes, "");
    }
  }

  function cellClassForPick(pick, correct, isFinal) {
    if (!isFinal) return "pending";
    if (correct === "Push") return "push";
    if (!pick) return "wrong";
    return norm(pick) === norm(correct) ? "correct" : "wrong";
  }

  function renderGrid(pickRows, gameIds, eventsById, linesById) {
    tbodyEl.innerHTML = "";

    // Sort entrants
    const rows = pickRows
      .filter(r => String(r.Name || "").trim() !== "")
      .sort((a,b) => String(a.Name||"").localeCompare(String(b.Name||"")));

    rows.forEach(r => {
      const tr = document.createElement("tr");
      tr.innerHTML = `<td class="name">${String(r.Name||"").trim()}</td>`;

      for (let i = 1; i <= 6; i++) {
        const gid = gameIds[i-1];
        const ev = gid ? eventsById.get(gid) : null;

        const advPick = String(r[`PickAdvancing${i}`] || "").trim();
        const atsPick = String(r[`PickATS${i}`] || "").trim();
        const ouPick  = String(r[`Pick OU${i}`] || "").trim(); // NOTE: space is required

        if (!gid || !ev) {
          tr.insertAdjacentHTML("beforeend", `
            <td class="pending">${advPick}</td>
            <td class="pending">${atsPick}</td>
            <td class="pending">${ouPick}</td>
          `);
          continue;
        }

        const info = eventToInfo(ev);

        // Adv is always based on winner
        const advClass = cellClassForPick(advPick, info.winnerTeam, info.isFinal);

        // ATS / OU need lines
        let atsClass = "pending", ouClass = "pending";
        if (info.isFinal) {
          const line = linesById.get(gid);
          if (line && !Number.isNaN(info.homeScore) && !Number.isNaN(info.awayScore)) {
            const atsWinner = computeATSWinner(info, line.homeSpread);
            const ouRes = computeOUResult(info, line.total);

            atsClass = cellClassForPick(atsPick, atsWinner, true);
            ouClass  = cellClassForPick(ouPick,  ouRes, true);
          }
        }

        tr.insertAdjacentHTML("beforeend", `
          <td class="${advClass}">${advPick}</td>
          <td class="${atsClass}">${atsPick}</td>
          <td class="${ouClass}">${ouPick}</td>
        `);
      }

      tbodyEl.appendChild(tr);
    });
  }

  function extractGameIdsWide(pickRows) {
    // Take first row that has GameID1 populated; assumes GameID1..6 are the same for all entrants
    const first = pickRows.find(r => String(r.GameID1 || "").trim() !== "");
    if (!first) return ["","","","","",""];
    const ids = [];
    for (let i = 1; i <= 6; i++) ids.push(String(first[`GameID${i}`] || "").trim());
    return ids;
  }

  async function main() {
    // Load picks + lines (repo-controlled)
    const picksText = await fetchTextOrNull("wildcard_picks.csv");
    const linesText = await fetchTextOrNull("lines.csv");

    if (!picksText) {
      msgEl.textContent = "Missing wildcard_picks.csv";
      buildHeaders(["Game 1","Game 2","Game 3","Game 4","Game 5","Game 6"]);
      return;
    }

    const pickRows = parseCSV(picksText);
    const gameIds = extractGameIdsWide(pickRows);

    // Load live scoreboard
    msgEl.textContent = "Loading gamesâ€¦";
    const data = await fetchJsonWithFallback(SCOREBOARD_URLS);

    // Index events by id
    const events = data.events || [];
    const eventsById = new Map();
    events.forEach(ev => { if (ev?.id) eventsById.set(String(ev.id), ev); });

    // Build matchup labels (from live event if found; otherwise placeholders)
    const matchups = gameIds.map((gid, idx) => {
      const ev = gid ? eventsById.get(gid) : null;
      if (!ev) return `Game ${idx+1}`;
      return matchupLabel(eventToInfo(ev));
    });
    buildHeaders(matchups);

    const linesById = linesText ? parseLines(linesText) : new Map();
    renderResults(gameIds, eventsById, linesById);
    renderGrid(pickRows, gameIds, eventsById, linesById);

    const missing = [];
    if (!linesText) missing.push("lines.csv");
    msgEl.textContent = missing.length ? `Loaded picks. Missing: ${missing.join(", ")}` : "Loaded picks and lines.";
  }

  main().catch(err => {
    console.error(err);
    msgEl.textContent = "Could not load data right now.";
    buildHeaders(["Game 1","Game 2","Game 3","Game 4","Game 5","Game 6"]);
  });
</script>
</body>
</html>
