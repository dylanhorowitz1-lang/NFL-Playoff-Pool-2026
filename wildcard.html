<!doctype html>
<html>
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Wild Card Picks</title>
  <style>
    :root{
      --bg:#0b1020;
      --card:#111a33;
      --card2:#0f1730;
      --text:#e8ecff;
      --muted:#a9b3da;
      --accent:#5eead4;
      --border: rgba(255,255,255,.12);
      --shadow: 0 12px 30px rgba(0,0,0,.35);
      --grid: rgba(255,255,255,.18);
      --sep: rgba(255,255,255,.38);
    }
    *{box-sizing:border-box}
    body{
      margin:0;
      font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Arial, "Apple Color Emoji","Segoe UI Emoji";
      background: radial-gradient(1200px 500px at 20% -10%, rgba(94,234,212,.18), transparent 60%),
                  radial-gradient(900px 500px at 100% 0%, rgba(99,102,241,.22), transparent 55%),
                  var(--bg);
      color:var(--text);
      min-height:100vh;
    }
    .wrap{max-width:1300px;margin:0 auto;padding:28px 16px 44px}
    .top{
      display:flex;align-items:flex-start;justify-content:space-between;gap:16px;flex-wrap:wrap;
      padding:18px 18px 10px;border:1px solid var(--border);border-radius:18px;background:rgba(17,26,51,.55);
      box-shadow: var(--shadow); backdrop-filter: blur(10px);
    }
    h1{margin:0;font-size:28px;letter-spacing:.2px}
    .sub{margin:6px 0 0;color:var(--muted);max-width:860px;line-height:1.45}
    .pill{
      display:inline-flex;align-items:center;gap:8px;
      padding:8px 10px;border:1px solid var(--border);border-radius:999px;
      color:var(--muted);font-size:12px;background:rgba(15,23,48,.55)
    }
    .nav{margin-top:12px;display:flex;gap:10px;flex-wrap:wrap;}
    .btn{
      display:inline-flex;align-items:center;gap:8px;
      padding:10px 12px;border-radius:12px;border:1px solid var(--border);
      background: rgba(15,23,48,.65);color:var(--text);text-decoration:none;
      transition: transform .12s ease, border-color .12s ease;
    }
    .btn:hover{transform: translateY(-1px);border-color: rgba(94,234,212,.45)}
    .card{
      margin-top:18px;border:1px solid var(--border);border-radius:18px;
      background: linear-gradient(180deg, rgba(17,26,51,.75), rgba(15,23,48,.65));
      box-shadow: var(--shadow);padding:14px;overflow-x:auto;
    }

    /* Table */
    table{
      border-collapse: collapse;
      width: 100%;
      min-width: 1400px;     /* more room for full team names */
      table-layout: fixed;   /* keep widths consistent */
    }

    /* Column sizing: Adv + Spread equal, O/U smaller */
    col.c-name { width: 200px; }
    col.c-adv  { width: 150px; }
    col.c-ats  { width: 150px; }
    col.c-ou   { width: 90px; }

    th, td{
      border: 1px solid var(--grid);
      padding: 7px 8px;
      text-align: center;
      vertical-align: middle;
      white-space: nowrap;
      overflow: hidden;
      text-overflow: clip; /* don't add Los... unless absolutely needed */
      font-size: 13px;
    }
    th.name, td.name{
      text-align: left;
      font-weight: 700;
      width: 200px;
    }
    thead th{
      position: sticky;
      top: 0;
      background: rgba(15,23,48,.95);
      z-index: 2;
    }

    /* separators between games */
    .sep{
      border-right: 3px solid var(--sep) !important;
    }

    /* result colors */
    .pending { background: #2a3357; }
    .correct { background: #1f6f4a; }
    .wrong   { background: #7a2b3a; }
    .push    { background: #6b5b1f; }

    /* results row label */
    .correct-row-label{
      text-align:left;
      font-weight:700;
      color: var(--muted);
      background: rgba(15,23,48,.55);
    }

    #msg { color: var(--muted); font-size: 12px; margin-top: 10px; }
  </style>
</head>
<body>
  <div class="wrap">
    <div class="top">
      <div>
        <h1>Wild Card Picks</h1>
        <p class="sub">Matchups and results load automatically. Picks load from <b>wildcard_picks.csv</b>. Lines load from <b>lines.csv</b>.</p>
        <div class="nav">
          <a class="btn" href="index.html">Home</a>
          <a class="btn" href="standings.html">Standings</a>
          <a class="btn" href="superbowl.html">Super Bowl Predictions</a>
          <a class="btn" href="games.html">NFL Scores</a>
        </div>
      </div>
      <div class="pill">Manual refresh</div>
    </div>

    <div id="msg"></div>

    <div class="card">
      <table id="picksTable">
        <!-- Enforce column widths: Name + (Adv, Spread, O/U) * 6 -->
        <colgroup>
          <col class="c-name">
          <col class="c-adv"><col class="c-ats"><col class="c-ou">
          <col class="c-adv"><col class="c-ats"><col class="c-ou">
          <col class="c-adv"><col class="c-ats"><col class="c-ou">
          <col class="c-adv"><col class="c-ats"><col class="c-ou">
          <col class="c-adv"><col class="c-ats"><col class="c-ou">
          <col class="c-adv"><col class="c-ats"><col class="c-ou">
        </colgroup>

        <thead id="thead"></thead>
        <tbody id="tbody"></tbody>
      </table>
    </div>
  </div>

<script>
  // ESPN scoreboard via proxy fallback (WIDE window: past + future)
  const BASE_SCOREBOARD = "https://site.api.espn.com/apis/site/v2/sports/football/nfl/scoreboard";

  function yyyymmdd(d){
    const y = d.getFullYear();
    const m = String(d.getMonth()+1).padStart(2,"0");
    const day = String(d.getDate()).padStart(2,"0");
    return `${y}${m}${day}`;
  }

  function buildScoreboardUrl(){
    // IMPORTANT: include past days so completed games still show up
    const start = new Date();
    start.setDate(start.getDate() - 10); // 10 days back

    const end = new Date();
    end.setDate(end.getDate() + 10);     // 10 days forward

    const range = `${yyyymmdd(start)}-${yyyymmdd(end)}`;
    return `${BASE_SCOREBOARD}?dates=${range}`;
  }

  const SCOREBOARD_URLS = (() => {
    const url = buildScoreboardUrl();
    return [
      "https://api.codetabs.com/v1/proxy/?quest=" + encodeURIComponent(url),
      "https://corsproxy.io/?" + encodeURIComponent(url),
      "https://api.allorigins.win/raw?url=" + encodeURIComponent(url)
    ];
  })();

  const msgEl = document.getElementById("msg");
  const theadEl = document.getElementById("thead");
  const tbodyEl = document.getElementById("tbody");

  function norm(s) { return String(s || "").trim().toLowerCase(); }

  function splitCSVLine(line) {
    const out = [];
    let cur = "", inQ = false;
    for (let i = 0; i < line.length; i++) {
      const ch = line[i];
      if (ch === '"') {
        if (inQ && line[i+1] === '"') { cur += '"'; i++; }
        else inQ = !inQ;
      } else if (ch === ',' && !inQ) {
        out.push(cur); cur = "";
      } else cur += ch;
    }
    out.push(cur);
    return out.map(x => x.trim());
  }

  function parseCSV(text) {
    const lines = text.replace(/\r/g, "").split("\n").filter(l => l.trim() !== "");
    if (lines.length < 2) return [];
    const headers = splitCSVLine(lines[0]);
    return lines.slice(1).map(line => {
      const cols = splitCSVLine(line);
      const obj = {};
      headers.forEach((h, i) => obj[h] = (cols[i] ?? ""));
      return obj;
    });
  }

  async function fetchJsonWithFallback(urls) {
    let lastErr = null;
    for (const u of urls) {
      try {
        const r = await fetch(u, { cache: "no-store" });
        if (!r.ok) { lastErr = new Error(`HTTP ${r.status}`); continue; }
        return await r.json();
      } catch (e) { lastErr = e; }
    }
    throw lastErr || new Error("Failed to fetch scoreboard");
  }

  async function fetchTextOrNull(path) {
    try {
      const r = await fetch(path, { cache: "no-store" });
      if (!r.ok) return null;
      return await r.text();
    } catch (e) { return null; }
  }

  // Lines: map GameID -> {homeSpread,total} AND preserve order from file
  function parseLinesWithOrder(linesText) {
    const rows = parseCSV(linesText);
    const map = new Map();
    const order = [];
    rows.forEach(r => {
      const gid = String(r.GameID || r.GAMEID || r.gameid || "").trim();
      const hs = Number(r.HomeSpread ?? r.homespread);
      const tot = Number(r.Total ?? r.total);
      if (!gid || Number.isNaN(hs) || Number.isNaN(tot)) return;
      if (!map.has(gid)) order.push(gid);
      map.set(gid, { homeSpread: hs, total: tot });
    });
    return { map, order };
  }

  function eventToInfo(ev) {
    const comp = ev.competitions?.[0];
    const teams = comp?.competitors || [];
    const away = teams.find(t => t.homeAway === "away");
    const home = teams.find(t => t.homeAway === "home");

    const awayName = away?.team?.displayName || "Away";
    const homeName = home?.team?.displayName || "Home";

    const awayScore = Number(away?.score ?? NaN);
    const homeScore = Number(home?.score ?? NaN);

    const isFinal = comp?.status?.type?.completed === true;
    const winnerTeam = isFinal ? (teams.find(t => t.winner === true)?.team?.displayName || "") : "";

    return { awayName, homeName, awayScore, homeScore, isFinal, winnerTeam };
  }

  function matchupLabel(info) {
    return `${info.awayName} @ ${info.homeName}`;
  }

  function computeATSWinner(info, homeSpread) {
    const adjHome = info.homeScore + homeSpread;
    if (adjHome > info.awayScore) return info.homeName;
    if (adjHome < info.awayScore) return info.awayName;
    return "Push";
  }

  function computeOUResult(info, total) {
    const sum = info.homeScore + info.awayScore;
    if (sum > total) return "Over";
    if (sum < total) return "Under";
    return "Push";
  }

  function buildHeaders(matchups, gameIds, eventsById, linesById) {
    // Row 1: Game matchups
    let row1 = `<tr><th class="name">Game</th>`;
    matchups.forEach((m, idx) => {
      const sepClass = (idx < matchups.length - 1) ? "sep" : "";
      row1 += `<th colspan="3" class="${sepClass}">${m}</th>`;
    });
    row1 += `</tr>`;

    // Row 2: Lines (always show if lines exist)
    let row2 = `<tr><th class="name">Lines</th>`;
    gameIds.forEach((gid, idx) => {
      const sepClass = (idx < gameIds.length - 1) ? "sep" : "";
      const line = gid ? linesById.get(gid) : null;
      const ev = gid ? eventsById.get(gid) : null;

      if (!gid || !line) {
        row2 += `<td colspan="3" class="${sepClass}">TBD</td>`;
        return;
      }

      // If ESPN exists, show team name with spread; otherwise just show numeric spread/total.
      let spreadText = `${line.homeSpread}`;
      if (ev) {
        const info = eventToInfo(ev);
        spreadText =
          line.homeSpread < 0
            ? `${info.homeName} ${line.homeSpread}`
            : `${info.awayName} -${line.homeSpread}`;
      }

      row2 += `<td colspan="3" class="${sepClass}">
                 ${spreadText} &nbsp; | &nbsp; O/U: ${line.total}
               </td>`;
    });
    row2 += `</tr>`;

    // Row 3: Results (label + cells)
    let row3 = `<tr><th class="name">Results</th>`;
    for (let i = 1; i <= 6; i++) {
      const sepClass = (i < 6) ? "sep" : "";
      row3 += `
        <td id="res_adv_${i}" class="pending">TBD</td>
        <td id="res_ats_${i}" class="pending">TBD</td>
        <td id="res_ou_${i}"  class="pending ${sepClass}">TBD</td>
      `;
    }
    row3 += `</tr>`;

    // Row 4: Pick labels
    let row4 = `<tr><th class="name">Name</th>`;
    for (let i = 1; i <= 6; i++) {
      const sepClass = (i < 6) ? "sep" : "";
      row4 += `<th>Adv</th><th>Spread</th><th class="${sepClass}">O/U</th>`;
    }
    row4 += `</tr>`;

    theadEl.innerHTML = row1 + row2 + row3 + row4;
  }

  function setResultsCell(id, text, cls) {
    const el = document.getElementById(id);
    if (!el) return;
    el.textContent = text;
    el.className = cls ? cls : "";
    if (id.includes("_ou_")) el.classList.add("sep");
  }

  function renderResults(gameIds, eventsById, linesById) {
    for (let i = 1; i <= 6; i++) {
      const gid = gameIds[i-1];
      const ev = gid ? eventsById.get(gid) : null;

      if (!gid || !ev) {
        setResultsCell(`res_adv_${i}`, "TBD", "pending");
        setResultsCell(`res_ats_${i}`, "TBD", "pending");
        setResultsCell(`res_ou_${i}`,  "TBD", "pending");
        continue;
      }

      const info = eventToInfo(ev);

      if (!info.isFinal) {
        setResultsCell(`res_adv_${i}`, "TBD", "pending");
        setResultsCell(`res_ats_${i}`, "TBD", "pending");
        setResultsCell(`res_ou_${i}`,  "TBD", "pending");
        continue;
      }

      setResultsCell(`res_adv_${i}`, info.winnerTeam || "Final", "");

      const line = linesById.get(gid);
      if (!line || Number.isNaN(info.homeScore) || Number.isNaN(info.awayScore)) {
        setResultsCell(`res_ats_${i}`, "Line missing", "pending");
        setResultsCell(`res_ou_${i}`,  "Line missing", "pending");
        continue;
      }

      setResultsCell(`res_ats_${i}`, computeATSWinner(info, line.homeSpread), "");
      setResultsCell(`res_ou_${i}`,  computeOUResult(info, line.total), "");
    }
  }

  function cellClassForPick(pick, correct, isFinal) {
    if (!isFinal) return "pending";
    if (correct === "Push") return "push";
    if (!pick) return "wrong";
    return norm(pick) === norm(correct) ? "correct" : "wrong";
  }

  function renderGrid(pickRows, gameIds, eventsById, linesById) {
    tbodyEl.innerHTML = "";

    const rows = pickRows.filter(r => String(r.Name || "").trim() !== ""); // keep CSV order

    rows.forEach(r => {
      const tr = document.createElement("tr");
      tr.innerHTML = `<td class="name">${String(r.Name||"").trim()}</td>`;

      for (let i = 1; i <= 6; i++) {
        const gid = gameIds[i-1];
        const ev = gid ? eventsById.get(gid) : null;

        const advPick = String(r[`PickAdvancing${i}`] || "").trim();
        const atsPick = String(r[`PickATS${i}`] || "").trim();
        const ouPick  = String(r[`Pick OU${i}`] || "").trim(); // exact header includes space

        if (!gid || !ev) {
          tr.insertAdjacentHTML("beforeend", `
            <td class="pending">${advPick}</td>
            <td class="pending">${atsPick}</td>
            <td class="pending sep">${ouPick}</td>
          `);
          continue;
        }

        const info = eventToInfo(ev);
        const advClass = cellClassForPick(advPick, info.winnerTeam, info.isFinal);

        let atsClass = "pending", ouClass = "pending";
        if (info.isFinal) {
          const line = linesById.get(gid);
          if (line && !Number.isNaN(info.homeScore) && !Number.isNaN(info.awayScore)) {
            const atsWinner = computeATSWinner(info, line.homeSpread);
            const ouRes = computeOUResult(info, line.total);
            atsClass = cellClassForPick(atsPick, atsWinner, true);
            ouClass  = cellClassForPick(ouPick,  ouRes, true);
          }
        }

        tr.insertAdjacentHTML("beforeend", `
          <td class="${advClass}">${advPick}</td>
          <td class="${atsClass}">${atsPick}</td>
          <td class="${ouClass} sep">${ouPick}</td>
        `);
      }

      tbodyEl.appendChild(tr);
    });
  }

  function extractGameIdsWide(pickRows) {
    const first = pickRows.find(r => String(r.GameID1 || "").trim() !== "");
    if (!first) return ["","","","","",""];
    const ids = [];
    for (let i = 1; i <= 6; i++) ids.push(String(first[`GameID${i}`] || "").trim());
    return ids;
  }

  async function main() {
    msgEl.textContent = "Loadingâ€¦";

    const picksText = await fetchTextOrNull("wildcard_picks.csv");
    const linesText = await fetchTextOrNull("lines.csv");

    const { map: linesById, order: lineOrder } =
      linesText ? parseLinesWithOrder(linesText) : { map: new Map(), order: [] };

    // Always load scoreboard so matchups/results can show (now includes past games too)
    const data = await fetchJsonWithFallback(SCOREBOARD_URLS);

    const eventsById = new Map();
    (data.events || []).forEach(ev => {
      // index by BOTH ids (some places use event.id, others use competition.id)
      if (ev?.id) eventsById.set(String(ev.id), ev);
      const compId = ev?.competitions?.[0]?.id;
      if (compId) eventsById.set(String(compId), ev);
    });

    let pickRows = [];
    let gameIds = ["","","","","",""];

    if (picksText) {
      pickRows = parseCSV(picksText);
      gameIds = extractGameIdsWide(pickRows);
    } else if (lineOrder.length) {
      gameIds = lineOrder.slice(0, 6);
    }

    const matchups = gameIds.map((gid, idx) => {
      const ev = gid ? eventsById.get(gid) : null;
      if (!ev) return `Game ${idx + 1}`;
      return matchupLabel(eventToInfo(ev));
    });

    buildHeaders(matchups, gameIds, eventsById, linesById);

    if (!linesText) msgEl.textContent = "Missing lines.csv (spreads/totals).";

    if (!picksText) {
      msgEl.textContent = (msgEl.textContent ? msgEl.textContent + " " : "") +
        "No picks yet (missing wildcard_picks.csv).";
      return;
    }

    renderResults(gameIds, eventsById, linesById);
    renderGrid(pickRows, gameIds, eventsById, linesById);

    msgEl.textContent =
      (!linesText ? "Loaded picks. Missing lines.csv." : "Loaded wildcard_picks.csv and lines.csv.");
  }

  main().catch(err => {
    console.error(err);
    msgEl.textContent = "Could not load data right now.";
    theadEl.innerHTML = `<tr><th class="name">Name</th></tr>`;
    tbodyEl.innerHTML = ``;
  });
</script>
</body>
</html>

