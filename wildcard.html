<!doctype html>
<html>
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Wild Card Picks</title>
  <style>
    :root{
      --bg:#0b1020;
      --card:#111a33;
      --card2:#0f1730;
      --text:#e8ecff;
      --muted:#a9b3da;
      --accent:#5eead4;
      --border: rgba(255,255,255,.12);
      --shadow: 0 12px 30px rgba(0,0,0,.35);
    }
    *{box-sizing:border-box}
    body{
      margin:0;
      font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Arial, "Apple Color Emoji","Segoe UI Emoji";
      background: radial-gradient(1200px 500px at 20% -10%, rgba(94,234,212,.18), transparent 60%),
                  radial-gradient(900px 500px at 100% 0%, rgba(99,102,241,.22), transparent 55%),
                  var(--bg);
      color:var(--text);
      min-height:100vh;
    }
    .wrap{max-width:1200px;margin:0 auto;padding:28px 16px 44px}
    .top{
      display:flex;align-items:flex-start;justify-content:space-between;gap:16px;flex-wrap:wrap;
      padding:18px 18px 10px;border:1px solid var(--border);border-radius:18px;background:rgba(17,26,51,.55);
      box-shadow: var(--shadow); backdrop-filter: blur(10px);
    }
    h1{margin:0;font-size:28px;letter-spacing:.2px}
    .sub{margin:6px 0 0;color:var(--muted);max-width:860px;line-height:1.45}
    .pill{
      display:inline-flex;align-items:center;gap:8px;
      padding:8px 10px;border:1px solid var(--border);border-radius:999px;
      color:var(--muted);font-size:12px;background:rgba(15,23,48,.55)
    }
    .nav{margin-top:12px;display:flex;gap:10px;flex-wrap:wrap;}
    .btn{
      display:inline-flex;align-items:center;gap:8px;
      padding:10px 12px;border-radius:12px;border:1px solid var(--border);
      background: rgba(15,23,48,.65);color:var(--text);text-decoration:none;
      transition: transform .12s ease, border-color .12s ease;
    }
    .btn:hover{transform: translateY(-1px);border-color: rgba(94,234,212,.45)}
    .card{
      margin-top:18px;border:1px solid var(--border);border-radius:18px;
      background: linear-gradient(180deg, rgba(17,26,51,.75), rgba(15,23,48,.65));
      box-shadow: var(--shadow);padding:14px;overflow-x:auto;
    }
    table { border-collapse: collapse; width: 100%; min-width: 900px; }
    th, td { border: 1px solid rgba(255,255,255,.18); padding: 6px; text-align: center; }
    th.name, td.name { text-align: left; font-weight: bold; white-space: nowrap; }

    .pending { background: #2a3357; }
    .correct { background: #1f6f4a; }
    .wrong   { background: #7a2b3a; }
    .push    { background: #6b5b1f; }

    #msg { color: var(--muted); font-size: 12px; margin-top: 10px; }
  </style>
</head>
<body>
  <div class="wrap">
    <div class="top">
      <div>
        <h1>Wild Card Picks</h1>
        <p class="sub">Matchups and results load automatically. Picks load from <b>wildcard_picks.csv</b>. Lines load from <b>lines.csv</b>.</p>
        <div class="nav">
          <a class="btn" href="index.html">Home</a>
          <a class="btn" href="standings.html">Standings</a>
          <a class="btn" href="superbowl.html">Super Bowl Predictions</a>
          <a class="btn" href="games.html">NFL Scores</a>
        </div>
      </div>
      <div class="pill">Manual refresh</div>
    </div>

    <div id="msg"></div>

    <div class="card">
      <table id="picksTable">
        <thead id="thead"></thead>
        <tbody id="tbody"></tbody>
      </table>
    </div>
  </div>

<script>
  // Pull a window so future Wild Card games appear (40 days from fixed Jan 5, 2026 ET)
  const BASE_SCOREBOARD = "https://site.api.espn.com/apis/site/v2/sports/football/nfl/scoreboard";

  function yyyymmdd(d){
    const y = d.getFullYear();
    const m = String(d.getMonth()+1).padStart(2,"0");
    const day = String(d.getDate()).padStart(2,"0");
    return `${y}${m}${day}`;
  }

  function buildScoreboardUrl(){
    const start = new Date("2026-01-05T00:00:00-05:00");
    const end = new Date(start);
    end.setDate(start.getDate() + 40);
    const range = `${yyyymmdd(start)}-${yyyymmdd(end)}`;
    return `${BASE_SCOREBOARD}?dates=${range}`;
  }

  const SCOREBOARD_URLS = (() => {
    const url = buildScoreboardUrl();
    return [
      "https://api.codetabs.com/v1/proxy/?quest=" + encodeURIComponent(url),
      "https://corsproxy.io/?" + encodeURIComponent(url)
    ];
  })();

  const msgEl = document.getElementById("msg");
  const theadEl = document.getElementById("thead");
  const tbodyEl = document.getElementById("tbody");

  function norm(s) { return String(s || "").trim().toLowerCase(); }

  function splitCSVLine(line) {
    const out = [];
    let cur = "", inQ = false;
    for (let i = 0; i < line.length; i++) {
      const ch = line[i];
      if (ch === '"') {
        if (inQ && line[i+1] === '"') { cur += '"'; i++; }
        else inQ = !inQ;
      } else if (ch === ',' && !inQ) {
        out.push(cur); cur = "";
      } else cur += ch;
    }
    out.push(cur);
    return out.map(x => x.trim());
  }

  function parseCSV(text) {
    const lines = text.replace(/\r/g, "").split("\n").filter(l => l.trim() !== "");
    if (lines.length < 2) return [];
    const headers = splitCSVLine(lines[0]);
    return lines.slice(1).map(line => {
      const cols = splitCSVLine(line);
      const obj = {};
      headers.forEach((h, i) => obj[h] = (cols[i] ?? ""));
      return obj;
    });
  }

  async function fetchJsonWithFallback(urls) {
    for (const u of urls) {
      try {
        const r = await fetch(u, { cache: "no-store" });
        if (!r.ok) continue;
        return await r.json();
      } catch (e) {}
    }
    throw new Error("Failed to fetch scoreboard");
  }

  async function fetchTextOrNull(path) {
    try {
      const r = await fetch(path, { cache: "no-store" });
      if (!r.ok) return null;
      return await r.text();
    } catch (e) { return null; }
  }

  // Parse lines.csv and preserve the 6 GameIDs order from the file
  function parseLinesWithOrder(linesText) {
    const rows = parseCSV(linesText);
    const map = new Map();
    const order = [];
    rows.forEach(r => {
      const gid = String(r.GameID || "").trim();
      const hs = Number(r.HomeSpread);
      const tot = Number(r.Total);
      if (!gid || Number.isNaN(hs) || Number.isNaN(tot)) return;
      if (!map.has(gid)) order.push(gid);
      map.set(gid, { homeSpread: hs, total: tot });
    });
    return { map, order };
  }

  function eventToInfo(ev) {
    const comp = ev.competitions?.[0];
    const teams = comp?.competitors || [];
    const away = teams.find(t => t.homeAway === "away");
    const home = teams.find(t => t.homeAway === "home");

    const awayName = away?.team?.displayName || "Away";
    const homeName = home?.team?.displayName || "Home";

    const awayScore = Number(away?.score ?? NaN);
    const homeScore = Number(home?.score ?? NaN);

    const isFinal = comp?.status?.type?.completed === true;
    const winnerTeam = isFinal ? (teams.find(t => t.winner === true)?.team?.displayName || "") : "";

    return { awayName, homeName, awayScore, homeScore, isFinal, winnerTeam };
  }

  function matchupLabel(info) {
    return `${info.awayName} @ ${info.homeName}`;
  }

  function computeATSWinner(info, homeSpread) {
    const adjHome = info.homeScore + homeSpread;
    if (adjHome > info.awayScore) return info.homeName;
    if (adjHome < info.awayScore) return info.awayName;
    return "Push";
  }

  function computeOUResult(info, total) {
    const sum = info.homeScore + info.awayScore;
    if (sum > total) return "Over";
    if (sum < total) return "Under";
    return "Push";
  }

  function buildHeaders(matchups, gameIds, eventsById, linesById) {
    // Row 1: Matchups
    let row1 = `<tr><th class="name" rowspan="4">Name</th>`;
    matchups.forEach(m => row1 += `<th colspan="3">${m}</th>`);
    row1 += `</tr>`;

    // Row 2: Spread / O-U
    let row2 = `<tr>`;
    gameIds.forEach(gid => {
      const ev = eventsById.get(gid);
      const line = linesById.get(gid);

      if (!gid || !ev || !line) {
        row2 += `<td colspan="3">Lines TBD</td>`;
        return;
      }

      const info = eventToInfo(ev);
      const favorite =
        line.homeSpread < 0
          ? `${info.homeName} ${line.homeSpread}`
          : `${info.awayName} -${line.homeSpread}`;

      row2 += `<td colspan="3">Spread: ${favorite} &nbsp; | &nbsp; O/U: ${line.total}</td>`;
    });
    row2 += `</tr>`;

    // Row 3: Correct results
    let row3 = `<tr>`;
    for (let i = 1; i <= 6; i++) {
      row3 += `
        <td class="pending" id="res_adv_${i}">TBD</td>
        <td class="pending" id="res_ats_${i}">TBD</td>
        <td class="pending" id="res_ou_${i}">TBD</td>
      `;
    }
    row3 += `</tr>`;

    // Row 4: labels
    let row4 = `<tr>`;
    for (let i = 1; i <= 6; i++) row4 += `<th>Adv</th><th>Spread</th><th>O/U</th>`;
    row4 += `</tr>`;

    theadEl.innerHTML = row1 + row2 + row3 + row4;
  }

  function setResultsCell(id, text, cls) {
    const el = document.getElementById(id);
    if (!el) return;
    el.textContent = text;
    el.className = cls || "";
  }

  function renderResults(gameIds, eventsById, linesById) {
    for (let i = 1; i <= 6; i++) {
      const gid = gameIds[i-1];
      const ev = gid ? eventsById.get(gid) : null;

      if (!gid || !ev) {
        setResultsCell(`res_adv_${i}`, "TBD", "pending");
        setResultsCell(`res_ats_${i}`, "TBD", "pending");
        setResultsCell(`res_ou_${i}`,  "TBD", "pending");
        continue;
      }

      const info = eventToInfo(ev);

      if (!info.isFinal) {
        setResultsCell(`res_adv_${i}`, "TBD", "pending");
        setResultsCell(`res_ats_${i}`, "TBD", "pending");
        setResultsCell(`res_ou_${i}`,  "TBD", "pending");
        continue;
      }

      setResultsCell(`res_adv_${i}`, info.winnerTeam || "Final", "");

      const line = linesById.get(gid);
      if (!line || Number.isNaN(info.homeScore) || Number.isNaN(info.awayScore)) {
        setResultsCell(`res_ats_${i}`, "Line missing", "pending");
        setResultsCell(`res_ou_${i}`,  "Line missing", "pending");
        continue;
      }

      setResultsCell(`res_ats_${i}`, computeATSWinner(info, line.homeSpread), "");
      setResultsCell(`res_ou_${i}`,  computeOUResult(info, line.total), "");
    }
  }

  function cellClassForPick(pick, correct, isFinal) {
    if (!isFinal) return "pending";
    if (correct === "Push") return "push";
    if (!pick) return "wrong";
    return norm(pick) === norm(correct) ? "correct" : "wrong";
  }

  function renderGrid(pickRows, gameIds, eventsById, linesById) {
    tbodyEl.innerHTML = "";

    const rows = pickRows
      .filter(r => String(r.Name || "").trim() !== "")
      .sort((a,b) => String(a.Name||"").localeCompare(String(b.Name||"")));

    rows.forEach(r => {
      const tr = document.createElement("tr");
      tr.innerHTML = `<td class="name">${String(r.Name||"").trim()}</td>`;

      for (let i = 1; i <= 6; i++) {
        const gid = gameIds[i-1];
        const ev = gid ? eventsById.get(gid) : null;

        const advPick = String(r[`PickAdvancing${i}`] || "").trim();
        const atsPick = String(r[`PickATS${i}`] || "").trim();
        const ouPick  = String(r[`Pick OU${i}`] || "").trim(); // space required

        if (!gid || !ev) {
          tr.insertAdjacentHTML("beforeend", `
            <td class="pending">${advPick}</td>
            <td class="pending">${atsPick}</td>
            <td class="pending">${ouPick}</td>
          `);
          continue;
        }

        const info = eventToInfo(ev);
        const advClass = cellClassForPick(advPick, info.winnerTeam, info.isFinal);

        let atsClass = "pending", ouClass = "pending";
        if (info.isFinal) {
          const line = linesById.get(gid);
          if (line && !Number.isNaN(info.homeScore) && !Number.isNaN(info.awayScore)) {
            const atsWinner = computeATSWinner(info, line.homeSpread);
            const ouRes = computeOUResult(info, line.total);
            atsClass = cellClassForPick(atsPick, atsWinner, true);
            ouClass  = cellClassForPick(ouPick,  ouRes, true);
          }
        }

        tr.insertAdjacentHTML("beforeend", `
          <td class="${advClass}">${advPick}</td>
          <td class="${atsClass}">${atsPick}</td>
          <td class="${ouClass}">${ouPick}</td>
        `);
      }

      tbodyEl.appendChild(tr);
    });
  }

  function extractGameIdsWide(pickRows) {
    const first = pickRows.find(r => String(r.GameID1 || "").trim() !== "");
    if (!first) return ["","","","","",""];
    const ids = [];
    for (let i = 1; i <= 6; i++) ids.push(String(first[`GameID${i}`] || "").trim());
    return ids;
  }

  async function main() {
    msgEl.textContent = "Loadingâ€¦";

    const picksText = await fetchTextOrNull("wildcard_picks.csv");
    const linesText = await fetchTextOrNull("lines.csv");

    // Lines are required to show Spread/O-U row
    const { map: linesById, order: lineOrder } = linesText ? parseLinesWithOrder(linesText) : { map: new Map(), order: [] };

    // Always load scoreboard so we can show matchup names even before picks arrive
    const data = await fetchJsonWithFallback(SCOREBOARD_URLS);
    const eventsById = new Map();
    (data.events || []).forEach(ev => { if (ev?.id) eventsById.set(String(ev.id), ev); });

    // Choose GameIDs:
    // 1) from picks file if present, else 2) from lines.csv order, else blanks
    let pickRows = [];
    let gameIds = ["","","","","",""];

    if (picksText) {
      pickRows = parseCSV(picksText);
      gameIds = extractGameIdsWide(pickRows);
    } else if (lineOrder.length) {
      gameIds = lineOrder.slice(0,6);
    }

    const matchups = gameIds.map((gid, idx) => {
      const ev = gid ? eventsById.get(gid) : null;
      if (!ev) return `Game ${idx+1}`;
      return matchupLabel(eventToInfo(ev));
    });

    buildHeaders(matchups, gameIds, eventsById, linesById);

    if (!picksText) {
      msgEl.textContent = "No picks yet (missing wildcard_picks.csv). Showing matchups + lines.";
      return;
    }

    renderResults(gameIds, eventsById, linesById);
    renderGrid(pickRows, gameIds, eventsById, linesById);

    msgEl.textContent = linesText ? "Loaded wildcard_picks.csv and lines.csv." : "Loaded picks. Missing lines.csv.";
  }

  main().catch(err => {
    console.error(err);
    msgEl.textContent = "Could not load data right now.";
    // safe fallback shell
    theadEl.innerHTML = `<tr><th class="name">Name</th></tr>`;
    tbodyEl.innerHTML = ``;
  });
</script>
</body>
</html>
